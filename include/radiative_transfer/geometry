#pragma once

#include<complex>
#include<random>
#include<filesystem>
#include<fstream>
#include<omp.h>
#include<iomanip>
#include<thread>
#include<chrono>

#include<Eigen/Dense>

#include"types"
#include"constants"
#include"utilities"

namespace radiative_transfer
{

inline std::vector<std::vector<std::vector<double>>> RadiativeTransferSolver::reconstruct(const std::vector<std::vector<std::vector<std::vector<double>>>>& F)
{
	std::vector<std::vector<std::vector<double>>> f = std::vector<std::vector<std::vector<double>>>(geometry_.Ntheta, std::vector<std::vector<double>>(geometry_.Ntheta, std::vector<double>(geometry_.Nphi, 0.0)));

	// #pragma omp parallel for
	for(int j = 0; j < geometry_.Ntheta; j ++)
	{
		for(int k = 0; k < geometry_.Ntheta; k ++)
		{
			for(int l = 0; l < geometry_.Nphi; l ++)
			{
				f[j][k][l] += F[0][j][k][0];

				for(int i = 1; i <= geometry_.M; i ++)
				{
					f[j][k][l] += 2.0 * (F[i][j][k][0] * std::cos(double(i) * geometry_.phi[l]) + F[i][j][k][1] * std::sin(double(i) * geometry_.phi[l]));
				}
			}
		}
	}

	return f;
}

inline std::vector<std::vector<Eigen::MatrixXd>> RadiativeTransferSolver::computeFourierSeriesCoefficients(const std::vector<std::vector<std::vector<double>>>& f)
{
	// std::vector<std::vector<std::vector<std::vector<double>>>> F = std::vector<std::vector<std::vector<std::vector<double>>>>(M + 1, std::vector<std::vector<std::vector<double>>>(Ntheta, std::vector<std::vector<double>>(Ntheta, std::vector<double>(2, 0.0))));

	double factor = geometry_.d_phi / (2.0 * PI);

	std::vector<Eigen::MatrixXd> Fcos = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));
	std::vector<Eigen::MatrixXd> Fsin = std::vector<Eigen::MatrixXd>(geometry_.M + 1, Eigen::MatrixXd::Zero(geometry_.Ntheta, geometry_.Ntheta));

	// double d_phi = geometry.phi[1] - geometry.phi[0];

	// std::cout << d_phi << std::endl;
	// std::cout << f.size() << std::endl;

	Eigen::MatrixXd C = Eigen::MatrixXd::Ones((geometry_.M + 1), geometry_.Nphi);
	Eigen::MatrixXd S = Eigen::MatrixXd::Zero((geometry_.M + 1), geometry_.Nphi);
	Eigen::RowVectorXd cphi(geometry_.Nphi);
	Eigen::RowVectorXd sphi(geometry_.Nphi);

	for(int p = 0; p < geometry_.Nphi; p ++)
	{
		cphi(p) = std::cos(geometry_.phi[p]);
		sphi(p) = std::sin(geometry_.phi[p]);
	}

	for(int i = 1; i <= geometry_.M; i ++)
	{
		C.row(i) = C.row(i - 1).cwiseProduct(cphi) - S.row(i - 1).cwiseProduct(sphi);
		S.row(i) = S.row(i - 1).cwiseProduct(cphi) + C.row(i - 1).cwiseProduct(sphi);
	}

	// 台形公式で積分
	// #pragma omp parallel for
	for(int i = 0; i <= geometry_.M; i ++)
	{
		for(int j = 0; j < geometry_.Ntheta; j ++)
		{
			for(int k = 0; k < geometry_.Ntheta; k ++)
			{
				const Eigen::Map<const Eigen::RowVectorXd> fjk(f[j][k].data(), geometry_.Nphi);
				Fcos[i](j, k) = fjk.dot(C.row(i)) * factor;
				Fsin[i](j, k) = fjk.dot(S.row(i)) * factor;
			}
		}
	}

	return {Fcos, Fsin};
}

/*
inline void RadiativeTransferSolver::reconstructOpticalProperties(RadiativeLayer &layer)
{
	std::vector<std::vector<std::vector<std::vector<double>>>> R_cs_top = std::vector<std::vector<std::vector<std::vector<double>>>>(geometry_.M + 1, std::vector<std::vector<std::vector<double>>>(geometry_.Ntheta, std::vector<std::vector<double>>(geometry_.Ntheta, std::vector<double>(2, 0.0))));
	std::vector<std::vector<std::vector<std::vector<double>>>> R_cs_bottom = std::vector<std::vector<std::vector<std::vector<double>>>>(geometry_.M + 1, std::vector<std::vector<std::vector<double>>>(geometry_.Ntheta, std::vector<std::vector<double>>(geometry_.Ntheta, std::vector<double>(2, 0.0))));
	std::vector<std::vector<std::vector<std::vector<double>>>> T_cs_top = std::vector<std::vector<std::vector<std::vector<double>>>>(geometry_.M + 1, std::vector<std::vector<std::vector<double>>>(geometry_.Ntheta, std::vector<std::vector<double>>(geometry_.Ntheta, std::vector<double>(2, 0.0))));
	std::vector<std::vector<std::vector<std::vector<double>>>> T_cs_bottom = std::vector<std::vector<std::vector<std::vector<double>>>>(geometry_.M + 1, std::vector<std::vector<std::vector<double>>>(geometry_.Ntheta, std::vector<std::vector<double>>(geometry_.Ntheta, std::vector<double>(2, 0.0))));

	for(int m = 0; m < R_cs_top.size(); m ++)
	{
		for(int e = 0; e < geometry_.Ntheta; e ++)
		{
			for(int i = 0; i < geometry_.Ntheta; i ++)
			{
				R_cs_top[m][e][i][0] = layer.reflectance_m_top_cos[m](e, i);
				R_cs_top[m][e][i][1] = layer.reflectance_m_top_sin[m](e, i);
				
				R_cs_bottom[m][e][i][0] = layer.reflectance_m_bottom_cos[m](e, i);
				R_cs_bottom[m][e][i][1] = layer.reflectance_m_bottom_sin[m](e, i);

				T_cs_top[m][e][i][0] = layer.transmittance_m_top_cos[m](e, i);
				T_cs_top[m][e][i][1] = layer.transmittance_m_top_sin[m](e, i);

				T_cs_bottom[m][e][i][0] = layer.transmittance_m_bottom_cos[m](e, i);
				T_cs_bottom[m][e][i][1] = layer.transmittance_m_bottom_sin[m](e, i);
			}
		}
	}

	// int n_phi = M * 2 + 3;
	layer.reflectance_top = reconstruct(R_cs_top);
	layer.reflectance_bottom = reconstruct(R_cs_bottom);
	layer.transmittance_top = reconstruct(T_cs_top);
	layer.transmittance_bottom = reconstruct(T_cs_bottom);

	return;
}

inline void RadiativeTransferSolver::computeFourierSeriesCoefficients(RadiativeLayer &layer)
{
	auto R_cs_top = computeFourierSeriesCoefficients(layer.reflectance_top);
	auto R_cs_bottom = computeFourierSeriesCoefficients(layer.reflectance_bottom);
	auto T_cs_top = computeFourierSeriesCoefficients(layer.transmittance_top);
	auto T_cs_bottom = computeFourierSeriesCoefficients(layer.transmittance_bottom);

	layer.reflectance_m_top_cos = R_cs_top[0];
	layer.reflectance_m_top_sin = R_cs_top[1];

	layer.reflectance_m_bottom_cos = R_cs_bottom[0];
	layer.reflectance_m_bottom_sin = R_cs_bottom[1];

	layer.transmittance_m_top_cos = T_cs_top[0];
	layer.transmittance_m_top_sin = T_cs_top[1];

	layer.transmittance_m_bottom_cos = T_cs_bottom[0];
	layer.transmittance_m_bottom_sin = T_cs_bottom[1];

	return;
}
*/
}
#pragma once

#include<Eigen/Dense>
#include<cmath>
#include<algorithm>

#include"types"
#include"constants"
#include"geometry"

namespace radiative_transfer
{

inline RadiativeLayer doubleLayer(const RadiativeLayer &layer, const Geometry &geometry)
{
	Eigen::VectorXd expu = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd expl = Eigen::VectorXd::Zero(geometry.Ntheta);

	for(int i = 0; i < geometry.Ntheta; i ++)
	{
		expu(i) = std::exp(-layer.optical_thickness / geometry.mu_uh(i));
		expl(i) = std::exp(-layer.optical_thickness / geometry.mu_lh(i));
	}

	auto result = layer;
	result.optical_thickness *= 2.0;

	if(layer.enable_atmospheric_emission == true)
	{
		result.enable_atmospheric_emission = true;
	}

	for(int m = 0; m <= geometry.M; m ++)
	{
		Eigen::MatrixXd Q1_c = (m == 0 ? 2.0 : 1.0) * layer.reflectance_m_bottom_cos[m] * geometry.WMU_uh * layer.reflectance_m_top_cos[m];
		Eigen::MatrixXd Q1_s = (m == 0 ? 2.0 : 1.0) * layer.reflectance_m_bottom_sin[m] * geometry.WMU_uh * layer.reflectance_m_top_sin[m];
		
		Eigen::MatrixXd Q2_c = (m == 0 ? 2.0 : 1.0) * Q1_c * geometry.WMU_lh;
		Eigen::MatrixXd Q2_s = (m == 0 ? 2.0 : 1.0) * Q1_s * geometry.WMU_lh;

		Eigen::MatrixXd E = Eigen::MatrixXd::Identity(geometry.Ntheta, geometry.Ntheta);
		Eigen::MatrixXd EQ_c = E - Q2_c;
		Eigen::MatrixXd EQ_s = E - Q2_s;

		Eigen::PartialPivLU<Eigen::MatrixXd> lu_c(EQ_c);
		Eigen::PartialPivLU<Eigen::MatrixXd> lu_s(EQ_s);
		Eigen::MatrixXd S_c = lu_c.solve(Q1_c);
		Eigen::MatrixXd S_s = lu_s.solve(Q1_s);

		Eigen::MatrixXd Sexp_c = S_c * expl.asDiagonal();
		Eigen::MatrixXd Sexp_s = S_s * expl.asDiagonal();

		Eigen::MatrixXd D_c = (m == 0 ? 2.0 : 1.0) * S_c * geometry.WMU_lh * layer.transmittance_m_top_cos[m];
		Eigen::MatrixXd D_s = (m == 0 ? 2.0 : 1.0) * S_s * geometry.WMU_lh * layer.transmittance_m_top_sin[m];

		D_c = D_c + layer.transmittance_m_top_cos[m] + Sexp_c;
		D_s = D_s + layer.transmittance_m_top_sin[m] + Sexp_s;

		Eigen::MatrixXd R2exp_c = layer.reflectance_m_top_cos[m] * expl.asDiagonal();
		Eigen::MatrixXd R2exp_s = layer.reflectance_m_top_sin[m] * expl.asDiagonal();

		Eigen::MatrixXd U_c = (m == 0 ? 2.0 : 1.0) * layer.reflectance_m_top_cos[m] * geometry.WMU_lh * D_c;
		Eigen::MatrixXd U_s = (m == 0 ? 2.0 : 1.0) * layer.reflectance_m_top_sin[m] * geometry.WMU_lh * D_s;

		U_c = U_c + R2exp_c;
		U_s = U_s + R2exp_s;

		Eigen::MatrixXd Uexp_c = expu.asDiagonal() * U_c;
		Eigen::MatrixXd Uexp_s = expu.asDiagonal() * U_s;

		result.reflectance_m_top_cos[m] = (m == 0 ? 2.0 : 1.0) * layer.transmittance_m_bottom_cos[m] * geometry.WMU_uh * U_c;
		result.reflectance_m_top_sin[m] = (m == 0 ? 2.0 : 1.0) * layer.transmittance_m_bottom_sin[m] * geometry.WMU_uh * U_s;

		result.reflectance_m_top_cos[m] = result.reflectance_m_top_cos[m] + layer.reflectance_m_top_cos[m] + Uexp_c;
		result.reflectance_m_top_sin[m] = result.reflectance_m_top_sin[m] + layer.reflectance_m_top_sin[m] + Uexp_s;

		Eigen::MatrixXd Dexp_c = expl.asDiagonal() * D_c;
		Eigen::MatrixXd Dexp_s = expl.asDiagonal() * D_s;

		Eigen::MatrixXd T2exp_c = layer.transmittance_m_top_cos[m] * expl.asDiagonal();
		Eigen::MatrixXd T2exp_s = layer.transmittance_m_top_sin[m] * expl.asDiagonal();

		result.transmittance_m_top_cos[m] = (m == 0 ? 2.0 : 1.0) * layer.transmittance_m_top_cos[m] * geometry.WMU_lh * D_c;
		result.transmittance_m_top_sin[m] = (m == 0 ? 2.0 : 1.0) * layer.transmittance_m_top_sin[m] * geometry.WMU_lh * D_s;

		result.transmittance_m_top_cos[m] = result.transmittance_m_top_cos[m] + T2exp_c + Dexp_c;
		result.transmittance_m_top_sin[m] = result.transmittance_m_top_sin[m] + T2exp_s + Dexp_s;

		if(m == 0 && result.enable_atmospheric_emission == true)
		{
			Eigen::VectorXd TE = layer.transmittance_m_bottom_cos[m] * geometry.WMU_uh * layer.source_up + expu.asDiagonal() * layer.source_up;
			Eigen::VectorXd TRE = layer.transmittance_m_bottom_cos[m] * geometry.WMU_uh * layer.reflectance_m_top_cos[m] * geometry.WMU_lh * layer.source_down + expu.asDiagonal() * layer.reflectance_m_top_cos[m] * geometry.WMU_lh * layer.source_down;
			Eigen::VectorXd TRSE = layer.transmittance_m_bottom_cos[m] * geometry.WMU_uh * layer.reflectance_m_top_cos[m] * geometry.WMU_lh * S_c * geometry.WMU_lh * layer.source_down;
			TRSE += expu.asDiagonal() * layer.reflectance_m_top_cos[m] * geometry.WMU_lh * S_c * geometry.WMU_lh * layer.source_down;
			result.source_up = layer.source_up + TE + TRE + TRSE;
			result.source_down = result.source_up;
		}
	}

	result.reflectance_m_bottom_cos = result.reflectance_m_top_cos;
	result.transmittance_m_bottom_cos = result.transmittance_m_top_cos;

	result.reflectance_m_bottom_sin = result.reflectance_m_top_sin;
	result.transmittance_m_bottom_sin = result.transmittance_m_top_sin;

	return result;
}

inline RadiativeLayer addLayer(const RadiativeLayer &layer_bottom, const RadiativeLayer &layer_top, const Geometry &geometry)
{
	Eigen::VectorXd expu_top = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd expl_top = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd expu_bottom = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd expl_bottom = Eigen::VectorXd::Zero(geometry.Ntheta);

	for(int i = 0; i < geometry.Ntheta; i ++)
	{
		expu_top(i) = std::exp(-layer_top.optical_thickness / geometry.mu_uh(i));
		expl_top(i) = std::exp(-layer_top.optical_thickness / geometry.mu_lh(i));
		expu_bottom(i) = std::exp(-layer_bottom.optical_thickness / geometry.mu_uh(i));
		expl_bottom(i) = std::exp(-layer_bottom.optical_thickness / geometry.mu_lh(i));
	}

	auto result = layer_bottom;
	result.optical_thickness = layer_bottom.optical_thickness + layer_top.optical_thickness;

	if(layer_bottom.enable_atmospheric_emission == true || layer_top.enable_atmospheric_emission == true)
	{
		result.enable_atmospheric_emission = true;
	}

	for(int m = 0; m <= geometry.M; m ++)
	{
		Eigen::MatrixXd Q1_c = (m == 0 ? 2.0 : 1.0) * layer_top.reflectance_m_bottom_cos[m] * geometry.WMU_uh * layer_bottom.reflectance_m_top_cos[m];
		Eigen::MatrixXd Q1_s = (m == 0 ? 2.0 : 1.0) * layer_top.reflectance_m_bottom_sin[m] * geometry.WMU_uh * layer_bottom.reflectance_m_top_sin[m];

		Eigen::MatrixXd Q2_c = (m == 0 ? 2.0 : 1.0) * Q1_c * geometry.WMU_lh;
		Eigen::MatrixXd Q2_s = (m == 0 ? 2.0 : 1.0) * Q1_s * geometry.WMU_lh;

		Eigen::MatrixXd E = Eigen::MatrixXd::Identity(geometry.Ntheta, geometry.Ntheta);
		Eigen::MatrixXd EQ_c = E - Q2_c;
		Eigen::MatrixXd EQ_s = E - Q2_s;

		Eigen::PartialPivLU<Eigen::MatrixXd> lu_c(EQ_c);
		Eigen::PartialPivLU<Eigen::MatrixXd> lu_s(EQ_s);
		Eigen::MatrixXd S_c = lu_c.solve(Q1_c);
		Eigen::MatrixXd S_s = lu_s.solve(Q1_s);

		Eigen::MatrixXd Sexp_c = S_c * expl_top.asDiagonal();
		Eigen::MatrixXd Sexp_s = S_s * expl_top.asDiagonal();

		Eigen::MatrixXd D_c = (m == 0 ? 2.0 : 1.0) * S_c * geometry.WMU_lh * layer_top.transmittance_m_top_cos[m];
		Eigen::MatrixXd D_s = (m == 0 ? 2.0 : 1.0) * S_s * geometry.WMU_lh * layer_top.transmittance_m_top_sin[m];

		D_c = D_c + layer_top.transmittance_m_top_cos[m] + Sexp_c;
		D_s = D_s + layer_top.transmittance_m_top_sin[m] + Sexp_s;

		Eigen::MatrixXd R2exp_c = result.reflectance_m_top_cos[m] * expl_top.asDiagonal();
		Eigen::MatrixXd R2exp_s = result.reflectance_m_top_sin[m] * expl_top.asDiagonal();

		Eigen::MatrixXd U_c = (m == 0 ? 2.0 : 1.0) * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * D_c;
		Eigen::MatrixXd U_s = (m == 0 ? 2.0 : 1.0) * layer_bottom.reflectance_m_top_sin[m] * geometry.WMU_lh * D_s;

		U_c = U_c + R2exp_c;
		U_s = U_s + R2exp_s;

		Eigen::MatrixXd Uexp_c = expu_top.asDiagonal() * U_c;
		Eigen::MatrixXd Uexp_s = expu_top.asDiagonal() * U_s;

		result.reflectance_m_top_cos[m] = (m == 0 ? 2.0 : 1.0) * layer_top.transmittance_m_bottom_cos[m] * geometry.WMU_uh * U_c;
		result.reflectance_m_top_sin[m] = (m == 0 ? 2.0 : 1.0) * layer_top.transmittance_m_bottom_sin[m] * geometry.WMU_uh * U_s;

		result.reflectance_m_top_cos[m] = result.reflectance_m_top_cos[m] + layer_top.reflectance_m_top_cos[m] + Uexp_c;
		result.reflectance_m_top_sin[m] = result.reflectance_m_top_sin[m] + layer_top.reflectance_m_top_sin[m] + Uexp_s;

		Eigen::MatrixXd Dexp_c = expl_bottom.asDiagonal() * D_c;
		Eigen::MatrixXd Dexp_s = expl_bottom.asDiagonal() * D_s;

		Eigen::MatrixXd T2exp_c = result.transmittance_m_top_cos[m] * expl_top.asDiagonal();
		Eigen::MatrixXd T2exp_s = result.transmittance_m_top_sin[m] * expl_top.asDiagonal();

		result.transmittance_m_top_cos[m] = (m == 0 ? 2.0 : 1.0) * layer_bottom.transmittance_m_top_cos[m] * geometry.WMU_lh * D_c;
		result.transmittance_m_top_sin[m] = (m == 0 ? 2.0 : 1.0) * layer_bottom.transmittance_m_top_sin[m] * geometry.WMU_lh * D_s;

		result.transmittance_m_top_cos[m] = result.transmittance_m_top_cos[m] + T2exp_c + Dexp_c;
		result.transmittance_m_top_sin[m] = result.transmittance_m_top_sin[m] + T2exp_s + Dexp_s;

		if(m == 0 && result.enable_atmospheric_emission == true)
		{
			// Eigen::VectorXd TE = layer_top.transmittance_m_bottom_cos[m] * geometry.WMU_uh * layer_bottom.source_up + expu_top.asDiagonal() * layer_bottom.source_up;
			// Eigen::VectorXd TRE = layer_top.transmittance_m_bottom_cos[m] * geometry.WMU_uh * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * layer_bottom.source_down + expu_top.asDiagonal() * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * layer_bottom.source_down;
			// Eigen::VectorXd TRSE = layer_top.transmittance_m_bottom_cos[m] * geometry.WMU_uh * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * S_c * geometry.WMU_lh * layer_bottom.source_down;
			// TRSE += expu_top.asDiagonal() * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * S_c * geometry.WMU_lh * layer_bottom.source_down;
			// result.source_up = layer_top.source_up + TE + TRE + TRSE;

			Eigen::VectorXd TE = layer_top.transmittance_m_bottom_cos[m] * geometry.WMU_uh * layer_bottom.source_up + expu_top.asDiagonal() * layer_bottom.source_up;
			Eigen::VectorXd TRE = layer_top.transmittance_m_bottom_cos[m] * geometry.WMU_uh * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * layer_top.source_down;
			TRE += expu_top.asDiagonal() * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * layer_top.source_down;
			Eigen::VectorXd TRSE = layer_top.transmittance_m_bottom_cos[m] * geometry.WMU_uh * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * S_c * geometry.WMU_lh * layer_top.source_down;
			TRSE += expu_top.asDiagonal() * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * S_c * geometry.WMU_lh * layer_top.source_down;
			// result.source_up = layer_top.source_up + TE + TRE + TRSE;
			result.source_up = layer_top.source_up + TE + TRE + TRSE;

			// std::cout << TRE << "\n";
		}
	}

	return result;
}

/*
inline RadiativeLayer doubleLayer_adjoint(const RadiativeLayer &layer, const Geometry &geometry, const RadiativeLayer &adj_result)
{
	// 1. 感度の初期化 (adj_layer)
	RadiativeLayer adj_layer = layer; // 構造体のサイズ合わせのためコピー
	// すべてのメンバをゼロ初期化（double/Matrix型のみ。bool等は無視）
	adj_layer.optical_thickness = 0.0;
	adj_layer.source_up.setZero();
	adj_layer.source_down.setZero();
	for(int m = 0; m <= geometry.M; m++) {
		adj_layer.reflectance_m_top_cos[m].setZero();
		adj_layer.reflectance_m_top_sin[m].setZero();
		adj_layer.reflectance_m_bottom_cos[m].setZero();
		adj_layer.reflectance_m_bottom_sin[m].setZero();
		adj_layer.transmittance_m_top_cos[m].setZero();
		adj_layer.transmittance_m_top_sin[m].setZero();
		adj_layer.transmittance_m_bottom_cos[m].setZero();
		adj_layer.transmittance_m_bottom_sin[m].setZero();
	}

	// 2. Primal計算での共通変数（expu, expl）の再計算
	Eigen::VectorXd expu = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd expl = Eigen::VectorXd::Zero(geometry.Ntheta);
	// 感度累積用
	Eigen::VectorXd adj_expu = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd adj_expl = Eigen::VectorXd::Zero(geometry.Ntheta);

	for(int i = 0; i < geometry.Ntheta; i ++)
	{
		expu(i) = std::exp(-layer.optical_thickness / geometry.mu_uh(i));
		expl(i) = std::exp(-layer.optical_thickness / geometry.mu_lh(i));
	}

	// 3. optical_thickness の直接的な感度 (result.optical_thickness *= 2.0 の逆)
	adj_layer.optical_thickness += adj_result.optical_thickness * 2.0;

	// 4. フーリエモードごとのループ
	// 独立しているので順序は問わないが、Primalと同じく0から回す
	for(int m = 0; m <= geometry.M; m ++)
	{
		// ==========================================
		// A. Forward (Primal) 再計算フェーズ
		// アジョイント計算に必要な中間変数(S, D, Uなど)を復元する
		// ==========================================
		double factor = (m == 0 ? 2.0 : 1.0);

		// Q行列
		Eigen::MatrixXd Q1_c = factor * layer.reflectance_m_bottom_cos[m] * geometry.WMU_uh * layer.reflectance_m_top_cos[m];
		Eigen::MatrixXd Q1_s = factor * layer.reflectance_m_bottom_sin[m] * geometry.WMU_uh * layer.reflectance_m_top_sin[m];
		
		Eigen::MatrixXd Q2_c = factor * Q1_c * geometry.WMU_lh;
		Eigen::MatrixXd Q2_s = factor * Q1_s * geometry.WMU_lh;

		// Interaction term (I - Q)^{-1}
		Eigen::MatrixXd E = Eigen::MatrixXd::Identity(geometry.Ntheta, geometry.Ntheta);
		Eigen::MatrixXd EQ_c = E - Q2_c;
		Eigen::MatrixXd EQ_s = E - Q2_s;

		Eigen::PartialPivLU<Eigen::MatrixXd> lu_c(EQ_c);
		Eigen::PartialPivLU<Eigen::MatrixXd> lu_s(EQ_s);
		Eigen::MatrixXd S_c = lu_c.solve(Q1_c);
		Eigen::MatrixXd S_s = lu_s.solve(Q1_s);

		// D行列
		Eigen::MatrixXd Sexp_c = S_c * expl.asDiagonal();
		Eigen::MatrixXd Sexp_s = S_s * expl.asDiagonal();

		Eigen::MatrixXd D_c_term1 = factor * S_c * geometry.WMU_lh * layer.transmittance_m_top_cos[m];
		Eigen::MatrixXd D_s_term1 = factor * S_s * geometry.WMU_lh * layer.transmittance_m_top_sin[m];

		Eigen::MatrixXd D_c = D_c_term1 + layer.transmittance_m_top_cos[m] + Sexp_c;
		Eigen::MatrixXd D_s = D_s_term1 + layer.transmittance_m_top_sin[m] + Sexp_s;

		// U行列
		Eigen::MatrixXd R2exp_c = layer.reflectance_m_top_cos[m] * expl.asDiagonal();
		Eigen::MatrixXd R2exp_s = layer.reflectance_m_top_sin[m] * expl.asDiagonal();

		Eigen::MatrixXd U_c_term1 = factor * layer.reflectance_m_top_cos[m] * geometry.WMU_lh * D_c;
		Eigen::MatrixXd U_s_term1 = factor * layer.reflectance_m_top_sin[m] * geometry.WMU_lh * D_s;

		Eigen::MatrixXd U_c = U_c_term1 + R2exp_c;
		Eigen::MatrixXd U_s = U_s_term1 + R2exp_s;

		// ==========================================
		// B. Backward (Adjoint) 計算フェーズ
		// 出力側の感度から入力側へ逆順に伝播させる
		// ==========================================
		
		// --- 最終結果の対称性処理の逆 ---
		// Primal: result.ref_bot = result.ref_top;
		// Adjoint: adj_top += adj_bot;
		Eigen::MatrixXd adj_ref_top_cos = adj_result.reflectance_m_top_cos[m] + adj_result.reflectance_m_bottom_cos[m];
		Eigen::MatrixXd adj_ref_top_sin = adj_result.reflectance_m_top_sin[m] + adj_result.reflectance_m_bottom_sin[m];
		Eigen::MatrixXd adj_trans_top_cos = adj_result.transmittance_m_top_cos[m] + adj_result.transmittance_m_bottom_cos[m];
		Eigen::MatrixXd adj_trans_top_sin = adj_result.transmittance_m_top_sin[m] + adj_result.transmittance_m_bottom_sin[m];

		// --- Emission (m=0) ---
		// ここは長いので、変数を一旦定義
		if(m == 0 && layer.enable_atmospheric_emission)
		{
			// Primal: result.source_up = layer.source_up + TE + TRE + TRSE;
			//         result.source_down = result.source_up;
			// Adjoint: adj_source_up に adj_result.up + adj_result.down が集まる
			Eigen::VectorXd adj_total_src = adj_result.source_up + adj_result.source_down;

			// 1. layer.source_up への直接寄与
			adj_layer.source_up += adj_total_src;

			// 2. TE項: T_bot * W_uh * src_up + expu * src_up
			// TE = (T_bot * W_uh + diag(expu)) * src_up
			Eigen::MatrixXd T_bot_W = layer.transmittance_m_bottom_cos[m] * geometry.WMU_uh;
			
			// src_up への寄与
			adj_layer.source_up += T_bot_W.transpose() * adj_total_src;
			adj_layer.source_up += expu.asDiagonal() * adj_total_src; // diag(expu)^T = diag(expu)

			// T_bot への寄与: TE = T_bot * (W_uh * src_up)
			Eigen::VectorXd W_src_up = geometry.WMU_uh * layer.source_up;
			adj_layer.transmittance_m_bottom_cos[m] += adj_total_src * W_src_up.transpose();

			// expu への寄与: TE = diag(expu) * src_up -> adj_expu = adj_TE . src_up (element-wise)
			adj_expu += adj_total_src.cwiseProduct(layer.source_up);


			// 3. TRE項: T_bot * W_uh * R_top * W_lh * src_down + expu * R_top * W_lh * src_down
			// 共通項: V = R_top * W_lh * src_down
			Eigen::VectorXd V = layer.reflectance_m_top_cos[m] * geometry.WMU_lh * layer.source_down;
			
			// TRE = T_bot * W_uh * V + expu * V
			// V に対する感度 adj_V
			Eigen::VectorXd adj_V = T_bot_W.transpose() * adj_total_src; // 前半
			adj_V += expu.asDiagonal() * adj_total_src;                  // 後半

			// T_bot への寄与
			Eigen::VectorXd W_V = geometry.WMU_uh * V;
			adj_layer.transmittance_m_bottom_cos[m] += adj_total_src * W_V.transpose();

			// expu への寄与
			adj_expu += adj_total_src.cwiseProduct(V);

			// V = R_top * (W_lh * src_down) から R_top, src_down へ
			Eigen::VectorXd W_src_down = geometry.WMU_lh * layer.source_down;
			adj_layer.reflectance_m_top_cos[m] += adj_V * W_src_down.transpose();
			adj_layer.source_down += (layer.reflectance_m_top_cos[m] * geometry.WMU_lh).transpose() * adj_V;


			// 4. TRSE項: (T_bot * W_uh * R_top * W_lh * S_c * W_lh * src_down) + (expu * R_top * W_lh * S_c * W_lh * src_down)
			// 共通項: V2 = R_top * W_lh * S_c * W_lh * src_down
			Eigen::VectorXd V2 = layer.reflectance_m_top_cos[m] * geometry.WMU_lh * S_c * geometry.WMU_lh * layer.source_down;
			
			// TRSE = T_bot * W_uh * V2 + expu * V2
			// V2 に対する感度
			Eigen::VectorXd adj_V2 = T_bot_W.transpose() * adj_total_src;
			adj_V2 += expu.asDiagonal() * adj_total_src;

			// T_bot, expu への寄与
			Eigen::VectorXd W_V2 = geometry.WMU_uh * V2;
			adj_layer.transmittance_m_bottom_cos[m] += adj_total_src * W_V2.transpose();
			adj_expu += adj_total_src.cwiseProduct(V2);

			// V2 = R_top * W_lh * S_c * W_lh * src_down
			// これを連鎖律で解く
			// Let X = S_c * W_lh * src_down
			Eigen::VectorXd X = S_c * geometry.WMU_lh * layer.source_down;
			// V2 = R_top * W_lh * X
			// R_top += adj_V2 * (W_lh * X)^T
			adj_layer.reflectance_m_top_cos[m] += adj_V2 * (geometry.WMU_lh * X).transpose();
			
			// Xへの感度: adj_X = W_lh^T * R_top^T * adj_V2
			Eigen::VectorXd adj_X = geometry.WMU_lh.transpose() * layer.reflectance_m_top_cos[m].transpose() * adj_V2;

			// X = S_c * (W_lh * src_down)
			// S_c への感度 (ここが重要: S_cは後でQ1, Q2へ伝播させる必要があるため、Matrixで保持)
			// adj_S_c (行列) += adj_X * (W_lh * src_down)^T
			// ※ ここでの adj_S_c は局所的な加算ですが、Transmittance/Reflectance計算からもS_cへの感度が来るため、
			//   ループ後半の S_c のバックプロパゲーションでまとめて処理するために変数を用意しておく必要があります。
			//   ここでは一時的に adj_S_c_from_emission とします。
			Eigen::MatrixXd adj_S_c_from_emission = adj_X * W_src_down.transpose();
			
			// src_down への感度
			adj_layer.source_down += (S_c * geometry.WMU_lh).transpose() * adj_X;
			
			// ※ adj_S_c_from_emission は後で adj_S_c に加算します
			//   （スコープの都合上、変数宣言はループ外か上位で行う必要がありますが、ここでは概念的に結合します）
			//   実際の実装では adj_S_c をゼロ初期化しておき、そこに足し込みます。
			//   以下のコードブロックでは adj_S_c をここで定義・加算したとみなして進めます。
		}

		// ----------------------------------------------------------------
		// Transmittance Backpropagation (Cos)
		// ----------------------------------------------------------------
		// Primal:
		// T_res = T2exp + Dexp + term1 (factor * T_top * W_lh * D_c)
		Eigen::MatrixXd adj_T_res_c = adj_trans_top_cos;

		// 1. T2exp = T_top * diag(expl)
		adj_layer.transmittance_m_top_cos[m] += adj_T_res_c * expl.asDiagonal();
		adj_expl += (layer.transmittance_m_top_cos[m].transpose() * adj_T_res_c).diagonal();

		// 2. Dexp = diag(expl) * D_c
		Eigen::MatrixXd adj_D_c = expl.asDiagonal() * adj_T_res_c; // D_cへの感度
		adj_expl += (adj_T_res_c * D_c.transpose()).diagonal();

		// 3. term1 = factor * T_top * W_lh * D_c
		// T_top への寄与
		adj_layer.transmittance_m_top_cos[m] += factor * adj_T_res_c * (geometry.WMU_lh * D_c).transpose();
		// D_c への寄与 (累積)
		adj_D_c += factor * (layer.transmittance_m_top_cos[m] * geometry.WMU_lh).transpose() * adj_T_res_c;

		// ----------------------------------------------------------------
		// Transmittance Backpropagation (Sin) - 全く同じ構造
		// ----------------------------------------------------------------
		Eigen::MatrixXd adj_T_res_s = adj_trans_top_sin;
		adj_layer.transmittance_m_top_sin[m] += adj_T_res_s * expl.asDiagonal();
		adj_expl += (layer.transmittance_m_top_sin[m].transpose() * adj_T_res_s).diagonal();

		Eigen::MatrixXd adj_D_s = expl.asDiagonal() * adj_T_res_s;
		adj_expl += (adj_T_res_s * D_s.transpose()).diagonal();

		adj_layer.transmittance_m_top_sin[m] += factor * adj_T_res_s * (geometry.WMU_lh * D_s).transpose();
		adj_D_s += factor * (layer.transmittance_m_top_sin[m] * geometry.WMU_lh).transpose() * adj_T_res_s;


		// ----------------------------------------------------------------
		// Reflectance Backpropagation (Cos)
		// ----------------------------------------------------------------
		// Primal:
		// R_res = R_top + Uexp + term1 (factor * T_bot * W_uh * U_c)
		Eigen::MatrixXd adj_R_res_c = adj_ref_top_cos;
		
		// 1. R_top (加算項)
		adj_layer.reflectance_m_top_cos[m] += adj_R_res_c;

		// 2. Uexp = diag(expu) * U_c
		Eigen::MatrixXd adj_U_c = expu.asDiagonal() * adj_R_res_c; // U_cへの感度
		adj_expu += (adj_R_res_c * U_c.transpose()).diagonal();

		// 3. term1 = factor * T_bot * W_uh * U_c
		adj_layer.transmittance_m_bottom_cos[m] += factor * adj_R_res_c * (geometry.WMU_uh * U_c).transpose();
		adj_U_c += factor * (layer.transmittance_m_bottom_cos[m] * geometry.WMU_uh).transpose() * adj_R_res_c;


		// ----------------------------------------------------------------
		// Reflectance Backpropagation (Sin)
		// ----------------------------------------------------------------
		Eigen::MatrixXd adj_R_res_s = adj_ref_top_sin;
		
		adj_layer.reflectance_m_top_sin[m] += adj_R_res_s;

		Eigen::MatrixXd adj_U_s = expu.asDiagonal() * adj_R_res_s;
		adj_expu += (adj_R_res_s * U_s.transpose()).diagonal();

		adj_layer.transmittance_m_bottom_sin[m] += factor * adj_R_res_s * (geometry.WMU_uh * U_s).transpose();
		adj_U_s += factor * (layer.transmittance_m_bottom_sin[m] * geometry.WMU_uh).transpose() * adj_R_res_s;


		// ----------------------------------------------------------------
		// Backprop through U
		// ----------------------------------------------------------------
		// Primal: U_c = (factor * R_top * W_lh * D_c) + (R_top * diag(expl))
		
		// 1. term1 = factor * R_top * W_lh * D_c
		adj_layer.reflectance_m_top_cos[m] += factor * adj_U_c * (geometry.WMU_lh * D_c).transpose();
		adj_D_c += factor * (layer.reflectance_m_top_cos[m] * geometry.WMU_lh).transpose() * adj_U_c;

		// 2. R2exp = R_top * diag(expl)
		adj_layer.reflectance_m_top_cos[m] += adj_U_c * expl.asDiagonal();
		adj_expl += (layer.reflectance_m_top_cos[m].transpose() * adj_U_c).diagonal();

		// Sin側
		adj_layer.reflectance_m_top_sin[m] += factor * adj_U_s * (geometry.WMU_lh * D_s).transpose();
		adj_D_s += factor * (layer.reflectance_m_top_sin[m] * geometry.WMU_lh).transpose() * adj_U_s;

		adj_layer.reflectance_m_top_sin[m] += adj_U_s * expl.asDiagonal();
		adj_expl += (layer.reflectance_m_top_sin[m].transpose() * adj_U_s).diagonal();


		// ----------------------------------------------------------------
		// Backprop through D
		// ----------------------------------------------------------------
		// Primal: D_c = term1(factor * S_c * W_lh * T_top) + T_top + Sexp
		
		// 1. T_top
		adj_layer.transmittance_m_top_cos[m] += adj_D_c;

		// 2. Sexp = S_c * diag(expl)
		Eigen::MatrixXd adj_S_c = adj_D_c * expl.asDiagonal();
		adj_expl += (S_c.transpose() * adj_D_c).diagonal();

		// 3. term1 = factor * S_c * W_lh * T_top
		adj_S_c += factor * adj_D_c * (geometry.WMU_lh * layer.transmittance_m_top_cos[m]).transpose();
		adj_layer.transmittance_m_top_cos[m] += factor * (S_c * geometry.WMU_lh).transpose() * adj_D_c;

		// Sin側
		adj_layer.transmittance_m_top_sin[m] += adj_D_s;

		Eigen::MatrixXd adj_S_s = adj_D_s * expl.asDiagonal();
		adj_expl += (S_s.transpose() * adj_D_s).diagonal();

		adj_S_s += factor * adj_D_s * (geometry.WMU_lh * layer.transmittance_m_top_sin[m]).transpose();
		adj_layer.transmittance_m_top_sin[m] += factor * (S_s * geometry.WMU_lh).transpose() * adj_D_s;

		// Emission項からのS_cへの寄与を加算 (if m==0)
		if(m == 0 && layer.enable_atmospheric_emission) {
			// 前述のEmission計算ブロックで計算すべき adj_S_c_from_emission を加算
			// ここでは再計算を省略し、概念的に以下を実行
			Eigen::VectorXd X = S_c * geometry.WMU_lh * layer.source_down;
			Eigen::VectorXd adj_V2 = (T_bot_W.transpose() + expu.asDiagonal()) * adj_total_src;
			Eigen::VectorXd adj_X = geometry.WMU_lh.transpose() * layer.reflectance_m_top_cos[m].transpose() * adj_V2;
			adj_S_c += adj_X * (geometry.WMU_lh * layer.source_down).transpose();
		}

		// ----------------------------------------------------------------
		// Backprop through Linear Solve S = (I - Q2)^-1 * Q1
		// ----------------------------------------------------------------
		// 関係式: S = EQ_inv * Q1
		// Adjoint:
		// adj_Q1 = EQ_inv^T * adj_S
		// adj_EQ = - (EQ_inv^T * adj_S) * S^T = - adj_Q1 * S^T
		// adj_Q2 = - adj_EQ = adj_Q1 * S^T

		// 1. adj_Q1 の計算 (LU分解済みなのでsolveを使う。EQ_c^T * x = adj_S_c -> x = EQ_c^{-T} * adj_S_c)
		// EigenのPartialPivLUは転置solveを直接サポートしていないため、転置行列で分解し直すか、
		// あるいは Ax=b を解く。ここでは数学的に EQ_c.transpose().solve(adj_S_c) です。
		// NOTE: PartialPivLUには transpose().solve() があります。
		
		Eigen::MatrixXd adj_Q1_c = lu_c.transpose().solve(adj_S_c);
		Eigen::MatrixXd adj_Q2_c = adj_Q1_c * S_c.transpose();

		Eigen::MatrixXd adj_Q1_s = lu_s.transpose().solve(adj_S_s);
		Eigen::MatrixXd adj_Q2_s = adj_Q1_s * S_s.transpose();

		// ----------------------------------------------------------------
		// Backprop through Q1, Q2
		// ----------------------------------------------------------------
		// Primal: Q2_c = factor * Q1_c * W_lh
		adj_Q1_c += factor * adj_Q2_c * geometry.WMU_lh.transpose();
		adj_Q1_s += factor * adj_Q2_s * geometry.WMU_lh.transpose();

		// Primal: Q1_c = factor * R_bot * W_uh * R_top
		// R_bot への寄与
		adj_layer.reflectance_m_bottom_cos[m] += factor * adj_Q1_c * (geometry.WMU_uh * layer.reflectance_m_top_cos[m]).transpose();
		// R_top への寄与
		adj_layer.reflectance_m_top_cos[m]    += factor * (layer.reflectance_m_bottom_cos[m] * geometry.WMU_uh).transpose() * adj_Q1_c;

		// Sin側
		adj_layer.reflectance_m_bottom_sin[m] += factor * adj_Q1_s * (geometry.WMU_uh * layer.reflectance_m_top_sin[m]).transpose();
		adj_layer.reflectance_m_top_sin[m]    += factor * (layer.reflectance_m_bottom_sin[m] * geometry.WMU_uh).transpose() * adj_Q1_s;
	}

	// 5. Exponentialからoptical_thicknessへの感度伝播
	// expu = exp(-tau/mu) -> d_expu/d_tau = -1/mu * expu
	for(int i = 0; i < geometry.Ntheta; i++)
	{
		adj_layer.optical_thickness += adj_expu(i) * (-1.0 / geometry.mu_uh(i)) * expu(i);
		adj_layer.optical_thickness += adj_expl(i) * (-1.0 / geometry.mu_lh(i)) * expl(i);
	}

	return adj_layer;
}

inline std::pair<RadiativeLayer, RadiativeLayer> addLayer_adjoint(const RadiativeLayer &layer_bottom, const RadiativeLayer &layer_top, const Geometry &geometry, const RadiativeLayer &adj_result)
{
	// 1. 感度の初期化
	// result = layer_bottom で初期化されていたため、
	// 更新されなかった変数の感度はそのまま bottom に伝わる
	RadiativeLayer adj_layer_bottom = adj_result; 
	
	// ただし、Primal計算内で値が「上書き」または「加算」された変数については、
	// 依存関係が変わるため、一旦ゼロにするか、注意深く扱う必要があります。
	// ここでは安全のため、構造体全体をゼロクリアしてから必要な部分を加算するアプローチをとります。
	// (構造体の全メンバをゼロにするヘルパー関数があると便利ですが、ここでは手動で行います)
	
	// --- ゼロクリア再初期化 ---
	// 下層: Primalで result = layer_bottom だったので、基本は adj_result をコピーするが、
	// ループ内で書き換えられる top_cos/sin, optical_thickness, source_up などは
	// 計算式に基づき逆伝播するため、ここでは result の "Pass-through" 成分以外はリセットしたい。
	// しかし実装の複雑さを避けるため、全メンバ0からスタートし、
	// 「resultの初期化による寄与」を明示的に足す形にします。
	
	RadiativeLayer adj_bot_temp = adj_result; // コピー
	// 全てのdouble/Matrixメンバを0にする (擬似コード的ですが、実際はメンバごとにsetZero)
	// optical_thickness, source, 行列全てを0にします。
	// ※ ここでは「adj_layer_bottom」「adj_layer_top」という変数名で、0から累積していくものとします。
	adj_layer_bottom = layer_bottom; // サイズ合わせ
	// メンバをゼロクリア
	adj_layer_bottom.optical_thickness = 0.0;
	adj_layer_bottom.source_up.setZero();
	adj_layer_bottom.source_down.setZero();
	for(int m=0; m<=geometry.M; m++){
		adj_layer_bottom.reflectance_m_top_cos[m].setZero(); adj_layer_bottom.reflectance_m_top_sin[m].setZero();
		adj_layer_bottom.reflectance_m_bottom_cos[m].setZero(); adj_layer_bottom.reflectance_m_bottom_sin[m].setZero();
		adj_layer_bottom.transmittance_m_top_cos[m].setZero(); adj_layer_bottom.transmittance_m_top_sin[m].setZero();
		adj_layer_bottom.transmittance_m_bottom_cos[m].setZero(); adj_layer_bottom.transmittance_m_bottom_sin[m].setZero();
	}
	RadiativeLayer adj_layer_top = adj_layer_bottom; // Topも同様にゼロクリア初期化

	// ----------------------------------------------------
	// A. "result = layer_bottom" による初期化の逆伝播
	// ----------------------------------------------------
	// ループ内で更新されなかったメンバ（bottom_cos, bottom_sin, source_down, (一部source_up)など）
	// は adj_result の値がそのまま adj_layer_bottom に入る。
	// 一方、更新されたメンバ (tau, top_cos/sin, trans_top_cos/sin, source_up) は
	// Primalのロジックに従って加算する。
	
	// まず、更新されていないメンバをコピー
	// (Primalコードでは reflectance_m_bottom, transmittance_m_bottom, source_down は更新されていない)
	adj_layer_bottom.reflectance_m_bottom_cos = adj_result.reflectance_m_bottom_cos;
	adj_layer_bottom.reflectance_m_bottom_sin = adj_result.reflectance_m_bottom_sin;
	adj_layer_bottom.transmittance_m_bottom_cos = adj_result.transmittance_m_bottom_cos;
	adj_layer_bottom.transmittance_m_bottom_sin = adj_result.transmittance_m_bottom_sin;
	adj_layer_bottom.source_down = adj_result.source_down;
	
	// source_up も emission フラグが無ければ更新されない可能性があるが、
	// Primalコードで enable_atmospheric_emission チェックがあるため後述のロジックに任せる。
	// ただし、Emissionが無効の場合は result.source_up = layer_bottom.source_up なので:
	if(!layer_bottom.enable_atmospheric_emission && !layer_top.enable_atmospheric_emission) {
		adj_layer_bottom.source_up += adj_result.source_up;
	}


	// ----------------------------------------------------
	// B. Primal 変数の再計算 (Forward Recomputation)
	// ----------------------------------------------------
	Eigen::VectorXd expu_top = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd expl_top = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd expu_bottom = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd expl_bottom = Eigen::VectorXd::Zero(geometry.Ntheta);

	for(int i = 0; i < geometry.Ntheta; i ++) {
		expu_top(i) = std::exp(-layer_top.optical_thickness / geometry.mu_uh(i));
		expl_top(i) = std::exp(-layer_top.optical_thickness / geometry.mu_lh(i));
		expu_bottom(i) = std::exp(-layer_bottom.optical_thickness / geometry.mu_uh(i));
		expl_bottom(i) = std::exp(-layer_bottom.optical_thickness / geometry.mu_lh(i));
	}

	// 感度累積用
	Eigen::VectorXd adj_expu_top = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd adj_expl_top = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd adj_expu_bottom = Eigen::VectorXd::Zero(geometry.Ntheta);
	Eigen::VectorXd adj_expl_bottom = Eigen::VectorXd::Zero(geometry.Ntheta);

	// 1. Optical Thickness
	// result.tau = bot.tau + top.tau
	adj_layer_bottom.optical_thickness += adj_result.optical_thickness;
	adj_layer_top.optical_thickness += adj_result.optical_thickness;


	// ----------------------------------------------------
	// C. Loop Backward
	// ----------------------------------------------------
	for(int m = 0; m <= geometry.M; m ++)
	{
		double factor = (m == 0 ? 2.0 : 1.0);

		// --- Forward Recomputation ---
		// Q, S, D, U などを再構築
		Eigen::MatrixXd Q1_c = factor * layer_top.reflectance_m_bottom_cos[m] * geometry.WMU_uh * layer_bottom.reflectance_m_top_cos[m];
		Eigen::MatrixXd Q1_s = factor * layer_top.reflectance_m_bottom_sin[m] * geometry.WMU_uh * layer_bottom.reflectance_m_top_sin[m];

		Eigen::MatrixXd Q2_c = factor * Q1_c * geometry.WMU_lh;
		Eigen::MatrixXd Q2_s = factor * Q1_s * geometry.WMU_lh;

		Eigen::MatrixXd E = Eigen::MatrixXd::Identity(geometry.Ntheta, geometry.Ntheta);
		Eigen::PartialPivLU<Eigen::MatrixXd> lu_c(E - Q2_c);
		Eigen::PartialPivLU<Eigen::MatrixXd> lu_s(E - Q2_s);
		Eigen::MatrixXd S_c = lu_c.solve(Q1_c);
		Eigen::MatrixXd S_s = lu_s.solve(Q1_s);

		Eigen::MatrixXd Sexp_c = S_c * expl_top.asDiagonal();
		Eigen::MatrixXd Sexp_s = S_s * expl_top.asDiagonal();

		Eigen::MatrixXd D_c_term1 = factor * S_c * geometry.WMU_lh * layer_top.transmittance_m_top_cos[m];
		Eigen::MatrixXd D_s_term1 = factor * S_s * geometry.WMU_lh * layer_top.transmittance_m_top_sin[m];
		Eigen::MatrixXd D_c = D_c_term1 + layer_top.transmittance_m_top_cos[m] + Sexp_c;
		Eigen::MatrixXd D_s = D_s_term1 + layer_top.transmittance_m_top_sin[m] + Sexp_s;

		// Note: R2exp_c uses result.reflectance BEFORE update. Since result=layer_bottom initially:
		Eigen::MatrixXd R2exp_c = layer_bottom.reflectance_m_top_cos[m] * expl_top.asDiagonal();
		Eigen::MatrixXd R2exp_s = layer_bottom.reflectance_m_top_sin[m] * expl_top.asDiagonal();

		Eigen::MatrixXd U_c_term1 = factor * layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * D_c;
		Eigen::MatrixXd U_s_term1 = factor * layer_bottom.reflectance_m_top_sin[m] * geometry.WMU_lh * D_s;
		Eigen::MatrixXd U_c = U_c_term1 + R2exp_c;
		Eigen::MatrixXd U_s = U_s_term1 + R2exp_s;

		// --- Backward Propagation Start ---
		
		// ----------------------------------------------------
		// 1. Emission (Source Up)
		// ----------------------------------------------------
		// S_c への感度がここから発生するため、Q, S のバックプロパより先に行う
		Eigen::MatrixXd adj_S_c_from_emit = Eigen::MatrixXd::Zero(geometry.Ntheta, geometry.Ntheta);

		if(m == 0 && (layer_bottom.enable_atmospheric_emission || layer_top.enable_atmospheric_emission))
		{
			// Primal: result.source_up = layer_top.source_up + TE + TRE + TRSE;
			Eigen::VectorXd adj_src = adj_result.source_up;

			// layer_top.source_up
			adj_layer_top.source_up += adj_src;

			// TE = T_bot_top * W * src_up_bot + expu_top * src_up_bot
			// Common: src_up_bot
			Eigen::MatrixXd T_W = layer_top.transmittance_m_bottom_cos[m] * geometry.WMU_uh;
			
			// to src_up_bot
			adj_layer_bottom.source_up += T_W.transpose() * adj_src;
			adj_layer_bottom.source_up += expu_top.asDiagonal() * adj_src;

			// to T_bot_top
			Eigen::VectorXd W_src_bot = geometry.WMU_uh * layer_bottom.source_up;
			adj_layer_top.transmittance_m_bottom_cos[m] += adj_src * W_src_bot.transpose();

			// to expu_top
			adj_expu_top += adj_src.cwiseProduct(layer_bottom.source_up);


			// TRE = T_bot_top * W * R_top_bot * W_lh * src_down_top + expu_top * R_top_bot * W_lh * src_down_top
			// Let V = R_top_bot * W_lh * src_down_top
			Eigen::VectorXd V = layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * layer_top.source_down;
			
			// adj_V (感度は TE と同様の構造)
			Eigen::VectorXd adj_V = T_W.transpose() * adj_src + expu_top.asDiagonal() * adj_src;

			// TRE terms to T_bot_top, expu_top
			Eigen::VectorXd W_V = geometry.WMU_uh * V;
			adj_layer_top.transmittance_m_bottom_cos[m] += adj_src * W_V.transpose();
			adj_expu_top += adj_src.cwiseProduct(V);

			// Backprop V = R_top_bot * (W_lh * src_down_top)
			Eigen::VectorXd W_src_down_top = geometry.WMU_lh * layer_top.source_down;
			adj_layer_bottom.reflectance_m_top_cos[m] += adj_V * W_src_down_top.transpose();
			adj_layer_top.source_down += (layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh).transpose() * adj_V;


			// TRSE = (T_bot_top * W + expu_top) * R_top_bot * W_lh * S_c * W_lh * src_down_top
			// Let V2 = R_top_bot * W_lh * S_c * W_lh * src_down_top
			Eigen::VectorXd V2 = layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh * S_c * geometry.WMU_lh * layer_top.source_down;

			Eigen::VectorXd adj_V2 = T_W.transpose() * adj_src + expu_top.asDiagonal() * adj_src;

			// to T_bot_top, expu_top
			Eigen::VectorXd W_V2 = geometry.WMU_uh * V2;
			adj_layer_top.transmittance_m_bottom_cos[m] += adj_src * W_V2.transpose();
			adj_expu_top += adj_src.cwiseProduct(V2);

			// Backprop V2 -> X = S_c * W_lh * src_down_top
			// V2 = R_top_bot * W_lh * X
			Eigen::VectorXd X = S_c * geometry.WMU_lh * layer_top.source_down;
			adj_layer_bottom.reflectance_m_top_cos[m] += adj_V2 * (geometry.WMU_lh * X).transpose();
			
			// to X -> S_c
			Eigen::VectorXd adj_X = geometry.WMU_lh.transpose() * layer_bottom.reflectance_m_top_cos[m].transpose() * adj_V2;
			
			// S_c への寄与を記録
			adj_S_c_from_emit = adj_X * W_src_down_top.transpose();

			// to src_down_top
			adj_layer_top.source_down += (S_c * geometry.WMU_lh).transpose() * adj_X;
		}

		// ----------------------------------------------------
		// 2. Transmittance Top (Result)
		// ----------------------------------------------------
		// Primal: result.T = T2exp + Dexp + term1 (factor * bot.T * W * D)
		Eigen::MatrixXd adj_T_res_c = adj_result.transmittance_m_top_cos[m];
		Eigen::MatrixXd adj_T_res_s = adj_result.transmittance_m_top_sin[m];

		// Dexp = diag(expl_bot) * D
		Eigen::MatrixXd adj_D_c = expl_bottom.asDiagonal() * adj_T_res_c;
		Eigen::MatrixXd adj_D_s = expl_bottom.asDiagonal() * adj_T_res_s;
		adj_expl_bottom += (adj_T_res_c * D_c.transpose()).diagonal();
		adj_expl_bottom += (adj_T_res_s * D_s.transpose()).diagonal();

		// T2exp = result.T(==bot.T before update) * diag(expl_top)
		// ここでの result.T は layer_bottom.T です
		adj_layer_bottom.transmittance_m_top_cos[m] += adj_T_res_c * expl_top.asDiagonal();
		adj_layer_bottom.transmittance_m_top_sin[m] += adj_T_res_s * expl_top.asDiagonal();
		adj_expl_top += (layer_bottom.transmittance_m_top_cos[m].transpose() * adj_T_res_c).diagonal();
		adj_expl_top += (layer_bottom.transmittance_m_top_sin[m].transpose() * adj_T_res_s).diagonal();

		// term1 = factor * bot.T * W_lh * D
		adj_layer_bottom.transmittance_m_top_cos[m] += factor * adj_T_res_c * (geometry.WMU_lh * D_c).transpose();
		adj_layer_bottom.transmittance_m_top_sin[m] += factor * adj_T_res_s * (geometry.WMU_lh * D_s).transpose();

		adj_D_c += factor * (layer_bottom.transmittance_m_top_cos[m] * geometry.WMU_lh).transpose() * adj_T_res_c;
		adj_D_s += factor * (layer_bottom.transmittance_m_top_sin[m] * geometry.WMU_lh).transpose() * adj_T_res_s;


		// ----------------------------------------------------
		// 3. Reflectance Top (Result)
		// ----------------------------------------------------
		// Primal: result.R = top.T_bot * W * U + top.R_top + Uexp
		Eigen::MatrixXd adj_R_res_c = adj_result.reflectance_m_top_cos[m];
		Eigen::MatrixXd adj_R_res_s = adj_result.reflectance_m_top_sin[m];

		// Uexp = diag(expu_top) * U
		Eigen::MatrixXd adj_U_c = expu_top.asDiagonal() * adj_R_res_c;
		Eigen::MatrixXd adj_U_s = expu_top.asDiagonal() * adj_R_res_s;
		adj_expu_top += (adj_R_res_c * U_c.transpose()).diagonal();
		adj_expu_top += (adj_R_res_s * U_s.transpose()).diagonal();

		// layer_top.reflectance_m_top (直接加算項)
		adj_layer_top.reflectance_m_top_cos[m] += adj_R_res_c;
		adj_layer_top.reflectance_m_top_sin[m] += adj_R_res_s;

		// term1 = factor * top.T_bot * W * U
		adj_layer_top.transmittance_m_bottom_cos[m] += factor * adj_R_res_c * (geometry.WMU_uh * U_c).transpose();
		adj_layer_top.transmittance_m_bottom_sin[m] += factor * adj_R_res_s * (geometry.WMU_uh * U_s).transpose();

		adj_U_c += factor * (layer_top.transmittance_m_bottom_cos[m] * geometry.WMU_uh).transpose() * adj_R_res_c;
		adj_U_s += factor * (layer_top.transmittance_m_bottom_sin[m] * geometry.WMU_uh).transpose() * adj_R_res_s;


		// ----------------------------------------------------
		// 4. Matrix U
		// ----------------------------------------------------
		// Primal: U = term1(factor * bot.R_top * W * D) + R2exp
		
		// R2exp = bot.R_top * diag(expl_top)
		adj_layer_bottom.reflectance_m_top_cos[m] += adj_U_c * expl_top.asDiagonal();
		adj_layer_bottom.reflectance_m_top_sin[m] += adj_U_s * expl_top.asDiagonal();
		adj_expl_top += (layer_bottom.reflectance_m_top_cos[m].transpose() * adj_U_c).diagonal();
		adj_expl_top += (layer_bottom.reflectance_m_top_sin[m].transpose() * adj_U_s).diagonal();

		// term1 = factor * bot.R_top * W * D
		adj_layer_bottom.reflectance_m_top_cos[m] += factor * adj_U_c * (geometry.WMU_lh * D_c).transpose();
		adj_layer_bottom.reflectance_m_top_sin[m] += factor * adj_U_s * (geometry.WMU_lh * D_s).transpose();
		
		adj_D_c += factor * (layer_bottom.reflectance_m_top_cos[m] * geometry.WMU_lh).transpose() * adj_U_c;
		adj_D_s += factor * (layer_bottom.reflectance_m_top_sin[m] * geometry.WMU_lh).transpose() * adj_U_s;


		// ----------------------------------------------------
		// 5. Matrix D
		// ----------------------------------------------------
		// Primal: D = term1(factor * S * W * top.T_top) + top.T_top + Sexp
		
		// top.transmittance_m_top (直接加算項)
		adj_layer_top.transmittance_m_top_cos[m] += adj_D_c;
		adj_layer_top.transmittance_m_top_sin[m] += adj_D_s;

		// Sexp = S * diag(expl_top)
		Eigen::MatrixXd adj_S_c = adj_D_c * expl_top.asDiagonal();
		Eigen::MatrixXd adj_S_s = adj_D_s * expl_top.asDiagonal();
		adj_expl_top += (S_c.transpose() * adj_D_c).diagonal();
		adj_expl_top += (S_s.transpose() * adj_D_s).diagonal();

		// term1 = factor * S * W * top.T_top
		adj_S_c += factor * adj_D_c * (geometry.WMU_lh * layer_top.transmittance_m_top_cos[m]).transpose();
		adj_S_s += factor * adj_D_s * (geometry.WMU_lh * layer_top.transmittance_m_top_sin[m]).transpose();

		adj_layer_top.transmittance_m_top_cos[m] += factor * (S_c * geometry.WMU_lh).transpose() * adj_D_c;
		adj_layer_top.transmittance_m_top_sin[m] += factor * (S_s * geometry.WMU_lh).transpose() * adj_D_s;

		// EmissionからのS_cへの寄与を加算
		if(m == 0) {
			adj_S_c += adj_S_c_from_emit;
		}

		// ----------------------------------------------------
		// 6. Interaction S & Q
		// ----------------------------------------------------
		// S = (I - Q2)^-1 * Q1
		Eigen::MatrixXd adj_Q1_c = lu_c.transpose().solve(adj_S_c);
		Eigen::MatrixXd adj_Q2_c = adj_Q1_c * S_c.transpose();

		Eigen::MatrixXd adj_Q1_s = lu_s.transpose().solve(adj_S_s);
		Eigen::MatrixXd adj_Q2_s = adj_Q1_s * S_s.transpose();

		// Q2 = factor * Q1 * W_lh
		adj_Q1_c += factor * adj_Q2_c * geometry.WMU_lh.transpose();
		adj_Q1_s += factor * adj_Q2_s * geometry.WMU_lh.transpose();

		// Q1 = factor * top.R_bot * W_uh * bot.R_top
		// to top.reflectance_m_bottom
		adj_layer_top.reflectance_m_bottom_cos[m] += factor * adj_Q1_c * (geometry.WMU_uh * layer_bottom.reflectance_m_top_cos[m]).transpose();
		adj_layer_top.reflectance_m_bottom_sin[m] += factor * adj_Q1_s * (geometry.WMU_uh * layer_bottom.reflectance_m_top_sin[m]).transpose();

		// to bottom.reflectance_m_top
		adj_layer_bottom.reflectance_m_top_cos[m] += factor * (layer_top.reflectance_m_bottom_cos[m] * geometry.WMU_uh).transpose() * adj_Q1_c;
		adj_layer_bottom.reflectance_m_top_sin[m] += factor * (layer_top.reflectance_m_bottom_sin[m] * geometry.WMU_uh).transpose() * adj_Q1_s;
	}

	// ----------------------------------------------------
	// D. Exponential Gradients
	// ----------------------------------------------------
	for(int i = 0; i < geometry.Ntheta; i++)
	{
		// Top Layer
		adj_layer_top.optical_thickness += adj_expu_top(i) * (-1.0 / geometry.mu_uh(i)) * expu_top(i);
		adj_layer_top.optical_thickness += adj_expl_top(i) * (-1.0 / geometry.mu_lh(i)) * expl_top(i);

		// Bottom Layer
		adj_layer_bottom.optical_thickness += adj_expu_bottom(i) * (-1.0 / geometry.mu_uh(i)) * expu_bottom(i);
		adj_layer_bottom.optical_thickness += adj_expl_bottom(i) * (-1.0 / geometry.mu_lh(i)) * expl_bottom(i);
	}

	return std::make_pair(adj_layer_bottom, adj_layer_top);
}
*/

}
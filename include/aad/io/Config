#pragma once

#include<fstream>
#include<iostream>
#include<map>
#include<sstream>
#include<string>
#include<vector>
#include<algorithm>

#include "Logger"
#include "../core/Types"
#include "../physics/Types"
#include "../utils/String"

namespace aad::io
{

class ConfigurationLoader
{
	public:
		static physics::Configuration load(const std::string&);

	private:
		static std::map<std::string, std::string> importYaml_(const std::string&);

		static physics::Configuration::Simulation loadSimulation_(const std::map<std::string, std::string>&);
		static physics::Configuration::Surface loadSurface_(const std::map<std::string, std::string>&);
		static physics::Configuration::Atmosphere loadAtmosphere_(const std::map<std::string, std::string>&);
		static physics::Configuration::GeometryConfiguration loadGeometry_(const std::map<std::string, std::string>&);
		static physics::Configuration::DeltaM loadDeltaM_(const std::map<std::string, std::string>&);
		static physics::Configuration::Instrument loadInstrument_(const std::map<std::string, std::string>&);
		static physics::Configuration::SpectralCoordinate loadSpectralCoordinate_(const std::map<std::string, std::string>&);

		static std::string getRequiredString_(const std::map<std::string, std::string>&, const std::string&);
		static int getRequiredInt_(const std::map<std::string, std::string>&, const std::string&);
		static double getRequiredDouble_(const std::map<std::string, std::string>&, const std::string&);
		static bool getRequiredBool_(const std::map<std::string, std::string>&, const std::string&);

		static std::string getOptionalString_(const std::map<std::string, std::string>&, const std::string&, const std::string&);
		static int getOptionalInt_(const std::map<std::string, std::string>&, const std::string&, int);
		static double getOptionalDouble_(const std::map<std::string, std::string>&, const std::string&, double);
		static bool getOptionalBool_(const std::map<std::string, std::string>&, const std::string&, bool);

		static std::optional<std::string> getOptionalString_(const std::map<std::string, std::string>&, const std::string&);
		static std::optional<int> getOptionalInt_(const std::map<std::string, std::string>&, const std::string&);
		static std::optional<double> getOptionalDouble_(const std::map<std::string, std::string>&, const std::string&);
		static std::optional<bool> getOptionalBool_(const std::map<std::string, std::string>&, const std::string&);

		static bool hasKey_(const std::map<std::string, std::string>&, const std::string&);
		static int countArrayEntries_(const std::map<std::string, std::string>&, const std::string&);

		template<typename EnumT> static std::optional<EnumT> parseEnum_(const std::optional<std::string>&, const std::map<std::string, EnumT>&);
};

inline physics::Configuration ConfigurationLoader::load(const std::string& filename)
{
	physics::Configuration configuration;
	auto kv = importYaml_(filename);

	configuration.simulation = loadSimulation_(kv);
	configuration.spectral_coordinate = loadSpectralCoordinate_(kv);
	configuration.instrument = loadInstrument_(kv);
	configuration.geometry = loadGeometry_(kv);
	configuration.delta_m = loadDeltaM_(kv);
	configuration.surface = loadSurface_(kv);
	configuration.atmosphere = loadAtmosphere_(kv);

	return configuration;
}

inline std::map<std::string, std::string> ConfigurationLoader::importYaml_(const std::string& filename)
{
	std::ifstream ifs(filename);
	if (!ifs)
	{
		global().fatal("ConfigurationLoader::importYaml_") << "Cannot open " + filename;
		throw std::runtime_error("Cannot open " + filename);
	}

	auto trim = [](std::string s) -> std::string
	{
		const auto ws = " \t\r\n";
		auto b = s.find_first_not_of(ws);

		if (b == std::string::npos)
		{
			return "";
		}

		auto e = s.find_last_not_of(ws);

		return s.substr(b, e - b + 1);
	};

	// splitFlow ラムダ（深さ depth によってカンマを分割）
	auto splitFlow = [&trim](std::string s) -> std::vector<std::string>
	{
		std::vector<std::string> elems;
		std::string cur;
		int depth = 0;
		
		for (size_t i = 0; i < s.size(); ++i)
		{
			char c = s[i];
			if(c == '[')
			{
				depth++;
				cur += c;
			}
			else if(c == ']')
			{
				depth--;
				cur += c;
			}
			else if(c == ',' && depth == 0)
			{
				elems.push_back(trim(cur));
				cur.clear();
			}
			else
			{
				cur += c;
			}
		}

		if (!cur.empty()) elems.push_back(trim(cur));

		return elems;
	};

	constexpr int INDENT = 2;
	int prev_depth = 0, line_no = 0;
	std::vector<std::string> stack;
	std::map<std::string,int> seqCount;
	std::map<std::string,std::string> kv;

	std::string line;
	while (std::getline(ifs, line))
	{
		++line_no;
		// コメント削除
		auto ph = line.find('#');
		std::string raw = (ph == std::string::npos ? line : line.substr(0,ph));
		if (trim(raw).empty()) continue;

		// インデント数カウント
		int nsp = 0;
		while (nsp < (int)raw.size() && raw[nsp]==' ') ++nsp;
		if (nsp % INDENT != 0)
		{
			global().fatal("ConfigurationLoader::importYaml_") << "Indent error at line " + std::to_string(line_no);
			throw std::runtime_error("Indent error at line " + std::to_string(line_no));
		}
		int depth = nsp / INDENT;
		if (depth > prev_depth + 1)
		{
			global().fatal("ConfigurationLoader::importYaml_") << "Nesting error at line " + std::to_string(line_no);
			throw std::runtime_error("Nesting error at line " + std::to_string(line_no));
		}
		prev_depth = depth;

		// 本文
		std::string body = trim(raw.substr(nsp));

		// ブロックシーケンス（- item）優先処理
		if (!body.empty() && body[0]=='-')
		{
			if (stack.empty())
			{
				global().fatal("ConfigurationLoader::importYaml_") << "Sequence item without parent at line " + std::to_string(line_no);
				throw std::runtime_error("Sequence item without parent at line " + std::to_string(line_no));
			}
		
			// prefix を組み立て（例: "species.2.vertical_profile.table"）
			std::string prefix = stack[0];
			for (int i = 1; i < (int)stack.size(); ++i)
			{
				prefix += "." + stack[i];
			}
		
			// "- " のあと、raw に "[1.0, 2e-13]" を取得
			std::string raw = trim(body.substr(1));
			int row = seqCount[prefix]++;
		
			// もし flow‐sequence なら "[" と "]" を外して splitFlow で分割
			if (raw.size() >= 2 && raw.front() == '[' && raw.back() == ']')
			{
				auto cols = splitFlow(raw.substr(1, raw.size()-2));
				for (size_t col = 0; col < cols.size(); ++col)
				{
					// species.2.vertical_profile.table.0.0 = "1.0"
					// species.2.vertical_profile.table.0.1 = "2.7576e-13"
					kv[prefix + "." 
					   + std::to_string(row) + "." 
					   + std::to_string(col)] = cols[col];
				}
			}
			else
			{
				// 通常の単一要素シーケンスはそのまま
				kv[prefix + "." + std::to_string(row)] = raw;
			}
			continue;
		}

		// key: ... 解析
		auto pc = body.find(':');
		if (pc == std::string::npos)
		{
			global().fatal("ConfigurationLoader::importYaml_") << "Syntax error at line " + std::to_string(line_no);
			throw std::runtime_error("Syntax error at line " + std::to_string(line_no));
		}
		std::string key = trim(body.substr(0,pc));
		std::string val = trim(body.substr(pc+1));

		if (val.empty())
		{
			// ネスト開始行
			if ((int)stack.size() > depth) stack.resize(depth);
			if ((int)stack.size() == depth) stack.push_back(key);
			else                         stack[depth] = key;
		}
		else
		{
			// 値付き行
			// クオート除去
			if ((val.front()=='"'&&val.back()=='"')||(val.front()=='\''&&val.back()=='\''))
				val = val.substr(1,val.size()-2);

			// フルパスキー
			std::string full = (depth==0 ? key : stack[0]);
			for (int i=1; i<depth; ++i) full += "." + stack[i];
			if (depth>0) full += "." + key;

			// フローシーケンスかどうか
			if (val.size()>=2 && val.front()=='[' && val.back()==']')
			{
				// 内部を切り出して、深さ0 のカンマで分割
				std::string inside = val.substr(1,val.size()-2);
				auto items = splitFlow(inside);

				for (size_t j=0; j<items.size(); ++j)
				{
					kv[full + "." + std::to_string(j)] = items[j];
				}
			}
			else 
			{
				// 通常のスカラー値
				kv[full] = val;
			}
		}
	}

	return kv;
}

inline physics::Configuration::Simulation ConfigurationLoader::loadSimulation_(const std::map<std::string, std::string>& kv)
{
	physics::Configuration::Simulation simulation;

	std::string prefix = "simulation.";

	simulation.simulation_name = getOptionalString_(kv, prefix + "name");
	std::optional<std::string> simulation_name_warning;
	if(!simulation.simulation_name.has_value())
	{
		simulation.simulation_name = "untitled";
		simulation_name_warning = "Simulation name was not specified. Automatically set to '" + simulation.simulation_name.value() + "'.";
	}

	simulation.directory_name = getOptionalString_(kv, prefix + "directory");
	std::optional<std::string> directory_name_warning;
	if(!simulation.directory_name.has_value())
	{
		simulation.directory_name = "./" + simulation.simulation_name.value();
		directory_name_warning = "Working directroy was not specified. Automatically set to \'" + simulation.directory_name.value() + "\'.";
	}
	if(simulation.directory_name.value()[simulation.directory_name.value().size() - 1] != '/')
	{
		simulation.directory_name = simulation.directory_name.value() + "/";
	}

	std::filesystem::path p(simulation.directory_name.value());
	if (!std::filesystem::exists(p))
	{
		std::filesystem::create_directories(p);
	}

	std::optional<std::string> logfile_name = getOptionalString_(kv, prefix + "logfile");
	std::optional<std::string> logfile_warning;
	if(!logfile_name.has_value())
	{
		logfile_name = "log_" + simulation.simulation_name.value_or("untitled") + ".txt";
		logfile_warning = "Log file name was not specified. Automatically set to '" + logfile_name.value() + "'.";
	}
	global().addSink(simulation.directory_name.value() + logfile_name.value(), false);
	global().setMinLevel(Level::Info);

	if(directory_name_warning.has_value())
	{
		global().warn("Configuration::validateConfiguration") << directory_name_warning.value();
	}
	if(simulation_name_warning.has_value())
	{
		global().warn("Configuration::validateConfiguration") << simulation_name_warning.value();
	}
	if(logfile_warning.has_value())
	{
		global().warn("Configuration::validateConfiguration") << logfile_warning.value();
	}
	
	simulation.n_parallel = getOptionalInt_(kv, prefix + "n_parallel");
	simulation.result_name = getOptionalString_(kv, prefix + "result");
	simulation.n_scattering_angle = getOptionalInt_(kv, prefix + "n_scattering_angle");
	simulation.tau_initial_layer = getOptionalDouble_(kv, prefix + "tau_initial_layer");
	simulation.enable_atmospheric_emission = getOptionalBool_(kv, prefix + "enable_atmospheric_emission");	

	return simulation;
}

inline physics::Configuration::SpectralCoordinate ConfigurationLoader::loadSpectralCoordinate_(const std::map<std::string, std::string>& kv)
{
	physics::Configuration::SpectralCoordinate spectral_coordinate;

	std::string prefix = "simulation.spectral_coordinate.";

	spectral_coordinate.spectral_coordinate_dimension = parseEnum_(getOptionalString_(kv, prefix + "dimension"), physics::map_spectral_coordinate_dimension);
	spectral_coordinate.spectral_coordinate_type = parseEnum_(getOptionalString_(kv, prefix + "type"), physics::map_spectral_coordinate_type);
	spectral_coordinate.unit = getOptionalString_(kv, prefix + "unit");

	spectral_coordinate.mono = getOptionalDouble_(kv, prefix + "value");

	// int n_lambda = countArrayEntries_(kv, prefix + "tics");
	// for(int i = 0; i < n_lambda; i ++)
	// {
	// 	spectral_coordinate.spectral_grid.push_back(getRequiredDouble_(kv, prefix + "tics." + std::to_string(i)));
	// }

	spectral_coordinate.min = getOptionalDouble_(kv, prefix + "min");
	spectral_coordinate.max = getOptionalDouble_(kv, prefix + "max");
	spectral_coordinate.increment = getOptionalDouble_(kv, prefix + "increment");
	spectral_coordinate.n_spectral = getOptionalInt_(kv, prefix + "count");

	return spectral_coordinate;
}

inline physics::Configuration::GeometryConfiguration ConfigurationLoader::loadGeometry_(const std::map<std::string, std::string>& kv)
{
	physics::Configuration::GeometryConfiguration geometry;

	std::string prefix = "simulation.grid.";

	geometry.grid_type = parseEnum_(getOptionalString_(kv, prefix + "type", "Gauss_Radau"), core::map_grid_type);

	geometry.n_theta = getOptionalInt_(kv, prefix + "n_zenith_angle");
	geometry.n_phi = getOptionalInt_(kv, prefix + "n_azimuth_angle");
	geometry.n_mode = getOptionalInt_(kv, prefix + "n_fourier_mode");

	return geometry;
}

inline physics::Configuration::DeltaM ConfigurationLoader::loadDeltaM_(const std::map<std::string, std::string>& kv)
{
	physics::Configuration::DeltaM delta_m;

	std::string prefix = "simulation.grid.delta_approximation.";

	delta_m.delta_approximation_type = parseEnum_(getOptionalString_(kv, prefix + "type"), physics::map_delta_approximation_type);
	delta_m.f_target = getOptionalDouble_(kv, prefix + "f_target");
	delta_m.fwhm_ratio = getOptionalDouble_(kv, prefix + "fwhm_ratio");
	delta_m.icss_type = parseEnum_(getOptionalString_(kv, prefix + "in_cell_supersampling.type"), physics::map_in_cell_super_sampling_type);
	delta_m.n_icss_sample = getOptionalInt_(kv, prefix + "in_cell_supersampling.n_sample");

	return delta_m;
}

inline physics::Configuration::Surface ConfigurationLoader::loadSurface_(const std::map<std::string, std::string>& kv)
{
	physics::Configuration::Surface surface;

	std::string prefix = "surface.";
	
	surface.type = parseEnum_(getOptionalString_(kv, prefix + "type"), physics::map_surface_type);
	surface.albedo = getOptionalDouble_(kv, prefix + "albedo");
	surface.emissivity = getOptionalDouble_(kv, prefix + "emissivity");
	surface.temperature = getOptionalDouble_(kv, prefix + "temperature");
	surface.unit = getOptionalString_(kv, prefix + "unit");

	return surface;
}

inline physics::Configuration::Atmosphere ConfigurationLoader::loadAtmosphere_(const std::map<std::string, std::string>& kv)
{
	physics::Configuration::Atmosphere atmosphere;

	std::string prefix = "atmosphere.";
	// layering
	{
		std::string base = prefix + "layering.";

		int n_edge = countArrayEntries_(kv, base + "z_edge");
		for(int i = 0; i < n_edge; i ++)
		{
			atmosphere.z_edge.push_back(getRequiredDouble_(kv, base + "z_edge." + std::to_string(i)));
		}

		int n_center = countArrayEntries_(kv, base + "z_center");
		for(int i = 0; i < n_center; i ++)
		{
			atmosphere.z_center.push_back(getRequiredDouble_(kv, base + "z_center." + std::to_string(i)));
		}

		atmosphere.z_unit = getOptionalString_(kv, base + "unit");
	}
	// temperature
	{
		std::string base = prefix + "temperature.";

		atmosphere.is_same_temperature_layering_atmosphere = hasKey_(kv, base + "table.0") && !hasKey_(kv, base + "table.0.1"); // tableがlayer*2でなければzのレイヤリングとは異なる
		atmosphere.vertical_temperature_profile = parseEnum_(getOptionalString_(kv, base + "vertical_profile"), physics::map_vertical_temperature_profile);
		atmosphere.vertical_temperature_interpolation = parseEnum_(getOptionalString_(kv, base + "interpolation"), physics::map_vertical_profile_interpolation);
		int n_tics = countArrayEntries_(kv, base + "table");

		if(atmosphere.is_same_temperature_layering_atmosphere)
		{
			atmosphere.temperature_unit = {getOptionalString_(kv, base + "unit")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.temperature_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i))});
			}

		}
		else
		{
			atmosphere.temperature_unit = {getOptionalString_(kv, base + "unit.0"), getOptionalString_(kv, base + "unit.1")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.temperature_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".0"), getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".1")});
			}
		}
	}
	// pressure
	{
		std::string base = prefix + "pressure.";

		atmosphere.is_same_pressure_layering_atmosphere = hasKey_(kv, base + "table.0") && !hasKey_(kv, base + "table.0.1"); // tableがlayer*2でなければzのレイヤリングとは異なる
		atmosphere.vertical_pressure_profile = parseEnum_(getOptionalString_(kv, base + "vertical_profile"), physics::map_vertical_pressure_profile);
		atmosphere.vertical_pressure_interpolation = parseEnum_(getOptionalString_(kv, base + "interpolation"), physics::map_vertical_profile_interpolation);
		
		int n_tics = countArrayEntries_(kv, base + "table");

		if(atmosphere.is_same_pressure_layering_atmosphere)
		{
			atmosphere.pressure_unit = {getOptionalString_(kv, base + "unit")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.pressure_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i))});
			}

		}
		else
		{
			atmosphere.pressure_unit = {getOptionalString_(kv, base + "unit.0"), getOptionalString_(kv, base + "unit.1")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.pressure_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".0"), getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".1")});
			}
		}
	}
	// number density
	{
		std::string base = prefix + "number_density.";

		atmosphere.is_same_number_density_layering_atmosphere = hasKey_(kv, base + "table.0") && !hasKey_(kv, base + "table.0.1"); // tableがlayer*2でなければzのレイヤリングとは異なる
		atmosphere.vertical_number_density_profile = parseEnum_(getOptionalString_(kv, base + "vertical_profile"), physics::map_vertical_number_density_profile);
		atmosphere.vertical_number_density_interpolation = parseEnum_(getOptionalString_(kv, base + "interpolation"), physics::map_vertical_profile_interpolation);
		
		int n_tics = countArrayEntries_(kv, base + "table");

		if(atmosphere.is_same_number_density_layering_atmosphere)
		{
			atmosphere.number_density_unit = {getOptionalString_(kv, base + "unit")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.number_density_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i))});
			}

		}
		else
		{
			atmosphere.number_density_unit = {getOptionalString_(kv, base + "unit.0"), getOptionalString_(kv, base + "unit.1")};
			
			for(int i = 0; i < n_tics; i ++)
			{
				atmosphere.number_density_profile.push_back({getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".0"), getRequiredDouble_(kv, base + "table." + std::to_string(i) + ".1")});
			}
		}
	}
	// hitran file
	{
		atmosphere.filename_hitran = getOptionalString_(kv, prefix + "hitran_file");
	}
	// diluent
	{
		int n_diluent = countArrayEntries_(kv, prefix + "diluent.table");
		for(int i = 0; i < n_diluent; i ++)
		{
			atmosphere.diluent_species.push_back(getRequiredString_(kv, prefix + "diluent.table." + std::to_string(i) + ".0"));
			atmosphere.diluent_ratio.push_back(getRequiredDouble_(kv, prefix + "diluent.table." + std::to_string(i) + ".1"));
		}
	}
	// species
	{
		int n_species = countArrayEntries_(kv, prefix + "species");
		
		atmosphere.species_configuration.clear();

		for(int i = 0; i < n_species; i ++)
		{
			std::string base = prefix + "species." + std::to_string(i) + ".";

			physics::Configuration::SpeciesConfiguration s;
			s.name = getOptionalString_(kv, base + "name");

			s.is_same_layering_atmosphere = !hasKey_(kv, base + "vertical_profile.table.0.1");
			s.vertical_profile_interpolation = parseEnum_(getOptionalString_(kv, base + "vertical_profile.interpolation"), physics::map_vertical_profile_interpolation);

			if(s.is_same_layering_atmosphere)
			{
				s.unit_vertical_profile = {getOptionalString_(kv, base + "vertical_profile.unit")};
				
				int n_tics = countArrayEntries_(kv, base + "vertical_profile.table");

				for(int j = 0; j < n_tics; j ++)
				{
					s.vertical_profile.push_back({getRequiredDouble_(kv, base + "vertical_profile.table." + std::to_string(j))});
				}
			}
			else
			{
				s.unit_vertical_profile = {getOptionalString_(kv, base + "vertical_profile.unit.0"), getOptionalString_(kv, base + "vertical_profile.unit.1")};
				
				int n_tics = countArrayEntries_(kv, base + "vertical_profile.table");

				for(int j = 0; j < n_tics; j ++)
				{
					s.vertical_profile.push_back({getRequiredDouble_(kv, base + "vertical_profile.table." + std::to_string(j) + ".0"), getRequiredDouble_(kv, base + "vertical_profile.table." + std::to_string(j) + ".1")});
				}
			}
		
			s.species_state = parseEnum_(getOptionalString_(kv, base + "state"), physics::map_species_state);
			s.species_type = parseEnum_(getOptionalString_(kv, base + "type"), physics::map_species_type);
			s.scatter_type = parseEnum_(getOptionalString_(kv, base + "scatter_type"), physics::map_scatter_type);
			s.scattering_cross_section_type = parseEnum_(getOptionalString_(kv, base + "scattering_cross_section.type"),physics::map_cross_section_type);
			s.absorption_cross_section_type = parseEnum_(getOptionalString_(kv, base + "absorption_cross_section.type"), physics::map_cross_section_type);

			// scattering_cross_section:
			//   type: external
			//   file:
			//     filename: filename
			//     varname: [wavenumber, scattering_cross_section]
			
			s.scattering_cross_section = getOptionalDouble_(kv, base + "scattering_cross_section.value");
			s.scattering_cross_section_unit = getOptionalString_(kv, base + "scattering_cross_section.unit");
			s.absorption_cross_section = getOptionalDouble_(kv, base + "absorption_cross_section.value");
			s.absorption_cross_section_unit = getOptionalString_(kv, base + "absorption_cross_section.unit");

			s.filename_scattering_cross_section = getOptionalString_(kv, base + "scattering_cross_section.file.filename");
			s.varname_scattering_cross_section_spectral = getOptionalString_(kv, base + "scattering_cross_section.file.varname.0");
			s.varname_scattering_cross_section_temperature = getOptionalString_(kv, base + "scattering_cross_section.file.varname.1");
			s.varname_scattering_cross_section = getOptionalString_(kv, base + "scattering_cross_section.file.varname.2");
			// s.unit_input_scattering_spectral = getOptionalString_(kv, base + "scattering_cross_section.unit.0");
			// s.unit_input_scattering_cross_section = getOptionalString_(kv, base + "scattering_cross_section.unit.1");
			s.filename_absorption_cross_section = getOptionalString_(kv, base + "absorption_cross_section.file.filename");
			s.varname_absorption_cross_section_spectral = getOptionalString_(kv, base + "absorption_cross_section.file.varname.0");
			s.varname_absorption_cross_section_temperature = getOptionalString_(kv, base + "absorption_cross_section.file.varname.1");
			s.varname_absorption_cross_section = getOptionalString_(kv, base + "absorption_cross_section.file.varname.2");
			// s.unit_input_absorption_spectral = getOptionalString_(kv, base + "absorption_cross_section.unit.0");
			// s.unit_input_absorption_cross_section = getOptionalString_(kv, base + "absorption_cross_section.unit.1");

			s.g_factor = getOptionalDouble_(kv, base + "g_factor");

			// hitran
			s.molecule_id = getOptionalInt_(kv, base + "molecule_id");
			
			if(hasKey_(kv, base + "isotopologues.local_id.0"))
			{
				s.isotopologue_type = physics::IsotopologueType::Defined;

				int n_iso = countArrayEntries_(kv, base + "isotopologues.local_id");
				for(int j = 0; j < n_iso; j ++)
				{
					s.local_isotopologue_id.push_back(getRequiredInt_(kv, base + "isotopologues.local_id." + std::to_string(j)));
				}
			}
			else
			{
				s.isotopologue_type = parseEnum_(getOptionalString_(kv, base + "isotopologues.local_id"), physics::map_isotopologue_type);
			}

			if(hasKey_(kv, base + "isotopologues.abundance.0"))
			{
				s.isotopologue_abundance_type = physics::IsotopologueAbundanceType::Defined;

				int n_iso = countArrayEntries_(kv, base + "isotopologues.abundance");
				for(int j = 0; j < n_iso; j ++)
				{
					s.abundance.push_back(getRequiredDouble_(kv, base + "isotopologues.abundance." + std::to_string(j)));
				}
			}
			else
			{
				s.isotopologue_abundance_type = parseEnum_(getOptionalString_(kv, base + "isotopologues.abundance"), physics::map_isotopologue_abundance_type);
			}

			int n_iso = countArrayEntries_(kv, base + "isotopologues.scalar");
			for(int j = 0; j < n_iso; j ++)
			{
				s.scalar.push_back(getRequiredDouble_(kv, base + "isotopologues.scalar." + std::to_string(j)));
			}

			s.is_normalize = getOptionalBool_(kv, base + "isotopologues.normalize");
			//ここまでhitran

			// 粒径分布の型と一般的な設定
			s.size_distribution = parseEnum_(getOptionalString_(kv, base + "size_distribution.function"), physics::map_particle_size_distribution);
			s.unit_input_radius = getOptionalString_(kv, base + "size_distribution.unit");
			s.count_radius = getOptionalInt_(kv, base + "size_distribution.n_sampling");

			// --- 1. Delta (r0) ---
			s.delta_r = getOptionalDouble_(kv, base + "size_distribution.r"); // r (単一半径)

			// --- 2. Rectangular ---
			s.rect_r_mean = getOptionalDouble_(kv, base + "size_distribution.r_mean");
			s.rect_width = getOptionalDouble_(kv, base + "size_distribution.width");

			// --- 3. Log-Normal (D.7: r_g, sigma_g) ---
			s.lnd_r_g = getOptionalDouble_(kv, base + "size_distribution.r_g");
			s.lnd_sigma_g = getOptionalDouble_(kv, base + "size_distribution.sigma_g");

			// --- 4. Gamma (D.5: a, b) ---
			s.gd_a = getOptionalDouble_(kv, base + "size_distribution.a");
			s.gd_b = getOptionalDouble_(kv, base + "size_distribution.b");

			// --- 5. Modified Gamma (D.6: r_c, alpha, gamma) ---
			s.mgd_r_c = getOptionalDouble_(kv, base + "size_distribution.r_c");
			s.mgd_alpha = getOptionalDouble_(kv, base + "size_distribution.alpha");
			s.mgd_gamma = getOptionalDouble_(kv, base + "size_distribution.gamma");

			// --- 6. Power Law (D.8: delta, r1, r2) ---
			s.pl_delta = getOptionalDouble_(kv, base + "size_distribution.delta");
			s.pl_r1 = getOptionalDouble_(kv, base + "size_distribution.r_1");
			s.pl_r2 = getOptionalDouble_(kv, base + "size_distribution.r_2");

			// ここまで粒径分布関数

			// ここから複素屈折率
			// 読み込みの例
			// refractive_index:
			//   type: constant
			//   value: [1.5014, 1.0E-3]

			// refractive_index:
			//   type: spectral
			//   file:
			//     filename: filename
			//     varname: [wavenumber, nr, ni]

			// refractive_index:
			//   type: vertical
			//   interpolation: linear
			//   unit: km
			//   table:
			//     - [0.0, 1.5, 1.0E-3]
			//     - [20.0, 1.5, 1.0E-3]
			//     - [100.0, 1.5, 1.0E-3]

			// refractive_index:
			//   type: spectral_vertical
			//   interpolation: linear
			//   file:
			//     filename: filename
			//     varname: [altitude, wavenumber, nr, ni]

			s.refractive_index_type = parseEnum_(getOptionalString_(kv, base + "refractive_index.type"), physics::map_refractive_index_type);

			// constant用
			s.nr = getOptionalDouble_(kv, base + "refractive_index.value.0");
			s.ni = getOptionalDouble_(kv, base + "refractive_index.value.1");

			// spectral用
			s.filename_refractive_index_spectral = getOptionalString_(kv, base + "refractive_index.file.filename");
			s.varname_refractive_index_spectral_spectral = getOptionalString_(kv, base + "refractive_index.file.varname.0");
			s.varname_refractive_index_spectral_nr = getOptionalString_(kv, base + "refractive_index.file.varname.1");
			s.varname_refractive_index_spectral_ni = getOptionalString_(kv, base + "refractive_index.file.varname.2");

			// vertical用
			s.refractive_index_vertical_profile_interpolation  = parseEnum_(getOptionalString_(kv, base + "refractive_index.interpolation"), physics::map_vertical_profile_interpolation);

			s.unit_refractive_index_vertical_profile = getOptionalString_(kv, base + "refractive_index.unit");
			if(hasKey_(kv, base + "refractive_index.table.0.2") == false)
			{
				s.is_refractive_index_same_layering_atmosphere = true;
			}
			int n_tics = countArrayEntries_(kv, base + "refractive_index.table");
			for(int j = 0; j < n_tics; j ++)
			{
				if(s.is_refractive_index_same_layering_atmosphere)
				{
					double nr = getRequiredDouble_(kv, base + "refractive_index.table." + std::to_string(j) + ".0");
					double ni = getRequiredDouble_(kv, base + "refractive_index.table." + std::to_string(j) + ".1");
					
					s.refractive_index_vertical_profile.push_back({nr, ni});
				}
				else
				{
					double alt = getRequiredDouble_(kv, base + "refractive_index.table." + std::to_string(j) + ".0");
					double nr = getRequiredDouble_(kv, base + "refractive_index.table." + std::to_string(j) + ".1");
					double ni = getRequiredDouble_(kv, base + "refractive_index.table." + std::to_string(j) + ".2");
					
					s.refractive_index_vertical_profile.push_back({alt, nr, ni});
				}
			}

			// spectral_vertical用
			s.filename_refractive_index_spectral_vertical = getOptionalString_(kv, base + "refractive_index.file.filename");
			s.varname_refractive_index_spectral_vertical_altitude = getOptionalString_(kv, base + "refractive_index.file.varname.0");
			s.varname_refractive_index_spectral_vertical_spectral = getOptionalString_(kv, base + "refractive_index.file.varname.1");
			s.varname_refractive_index_spectral_vertical_nr = getOptionalString_(kv, base + "refractive_index.file.varname.2");
			s.varname_refractive_index_spectral_vertical_ni = getOptionalString_(kv, base + "refractive_index.file.varname.3");

			atmosphere.species_configuration.push_back(s);
		}
	}

	return atmosphere;
}

inline physics::Configuration::Instrument ConfigurationLoader::loadInstrument_(const std::map<std::string, std::string>& kv)
{
	physics::Configuration::Instrument instrument;

	// spectral_coordinate:
    //   dimension: wavenumber
    //   type: Spectrum
    //   min: 7.67
    //   max: 7.71
    //   increment: 100
    //   count: 1001
    //   unit: cm-1
	// bandpass_filter:
	//   type: gauss, rectangle, external
	//   file: filename
	//   sigma:
	//   width:
	//   center:
	//   cutoff_sigma:
	//   n_sample:
	//   file:
	//     filename: 
	//     cutoff:
	//     varname: [wavenumber, transmittance]
	// convolution_kernel:
	//   type: gauss, rectangle
	//   sigma: 0.1
	//   width: 0.1
	//   cutoff_sigma: 4.0
	//   n_sample: 5
	//   

	std::string prefix = "simulation.convolution_kernel.";

	instrument.convolution_kernel_type = parseEnum_(getOptionalString_(kv, prefix + "type"), physics::map_instrument_function_type);
	instrument.kernel_sigma = getOptionalDouble_(kv, prefix + "sigma");
	instrument.kernel_width = getOptionalDouble_(kv, prefix + "width");
	instrument.over_sampling_count = getOptionalInt_(kv, prefix + "n_sample");
	instrument.kernel_cut_off_sigma = getOptionalDouble_(kv, prefix + "cutoff_sigma");

	prefix = "simulation.bandpass_filter.";

	instrument.filter_function_type = parseEnum_(getOptionalString_(kv, prefix + "type"), physics::map_instrument_function_type);
	instrument.filter_sigma = getOptionalDouble_(kv, prefix + "sigma");
	instrument.filter_width = getOptionalDouble_(kv, prefix + "width");
	instrument.filter_center = getOptionalDouble_(kv, prefix + "center");
	instrument.sampling_count = getOptionalInt_(kv, prefix + "n_sample");
	instrument.filter_cut_off_sigma = getOptionalDouble_(kv, prefix + "cutoff_sigma");
	instrument.filename_filter_function = getOptionalString_(kv, prefix + "file.filename");
	instrument.varname_spectral = getOptionalString_(kv, prefix + "file.varname.0");
	instrument.varname_transmittance = getOptionalString_(kv, prefix + "file.varname.1");
	instrument.filter_cut_off = getOptionalDouble_(kv, prefix + "file.cutoff");

	return instrument;
}

inline std::string ConfigurationLoader::getRequiredString_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	auto it = kv.find(key);

	if (it == kv.end())
	{
		global().fatal("ConfigurationLoader::getRequiredString_") << "Missing key: " + key;
		throw std::runtime_error("Missing key: " + key);
	}

	return it -> second;
}

inline int ConfigurationLoader::getRequiredInt_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	auto it = kv.find(key);

	if (it == kv.end())
	{
		global().fatal("ConfigurationLoader::getRequiredInt_") << "Missing key: " + key;
		throw std::runtime_error("Missing key: " + key);
	}

	return std::stoi(it -> second);
}

inline double ConfigurationLoader::getRequiredDouble_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	auto it = kv.find(key);

	if (it == kv.end())
	{
		global().fatal("ConfigurationLoader::getRequiredDouble_") << "Missing key: " + key;
		throw std::runtime_error("Missing key: " + key);
	}

	return std::stod(it -> second);
}

inline bool ConfigurationLoader::getRequiredBool_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	auto it = kv.find(key);

	if (it == kv.end())
	{
		global().fatal("ConfigurationLoader::getRequiredBool_") <<"Missing key: " + key;
		throw std::runtime_error("Missing key: " + key);
	}

	std::string s = utils::toLower(it->second);

	if (s == "true"  || s == "yes" || s == "on")  return true;
	if (s == "false" || s == "no"  || s == "off") return false;

	// ここまで来たら値は存在するが真偽値として解釈不能
	global().fatal("ConfigurationLoader::getRequiredBool_") << "Invalid boolean value for key '" + key + "': '" + it->second + "'";
	throw std::runtime_error("Invalid boolean value for key '" + key + "': '" + it->second + "'");
}

inline std::string ConfigurationLoader::getOptionalString_(const std::map<std::string, std::string>& kv, const std::string& key, const std::string& def)
{
	auto it = kv.find(key);

	return (it == kv.end() ? def : it->second);
}

inline int ConfigurationLoader::getOptionalInt_(const std::map<std::string, std::string>& kv, const std::string& key, int def)
{
	auto it = kv.find(key);

	return (it == kv.end() ? def : std::stoi(it->second));
}

inline double ConfigurationLoader::getOptionalDouble_(const std::map<std::string, std::string>& kv, const std::string& key, double def)
{
	auto it = kv.find(key);

	return (it == kv.end() ? def : std::stod(it->second));
}

inline bool ConfigurationLoader::getOptionalBool_(const std::map<std::string, std::string>& kv, const std::string& key, bool def)
{
	auto it = kv.find(key);

	if (it == kv.end())
	{
		return def;
	}

	std::string s = utils::toLower(it->second);

	if (s == "true"  || s == "yes" || s == "on")  return true;
	if (s == "false" || s == "no"  || s == "off") return false;

	// ここまで来たら値は存在するが真偽値として解釈不能
	
	global().fatal("ConfigurationLoader::getOptionalBool_") << "Invalid boolean value for key '" + key + "': '" + it->second + "'";
	throw std::runtime_error("Invalid boolean value for key '" + key + "': '" + it->second + "'");
}

inline std::optional<std::string> ConfigurationLoader::getOptionalString_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	std::optional<std::string> result;

	auto it = kv.find(key);

	if(it == kv.end())
	{
		result.reset();
	}
	else
	{
		result = it->second;
	}

	return result;
}

inline std::optional<int> ConfigurationLoader::getOptionalInt_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	std::optional<int> result;

	auto it = kv.find(key);

	if(it == kv.end())
	{
		result.reset();
	}
	else
	{
		result = std::stoi(it->second);
	}

	return result;
}

inline std::optional<double> ConfigurationLoader::getOptionalDouble_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	std::optional<double> result;

	auto it = kv.find(key);

	if(it == kv.end())
	{
		result.reset();
	}
	else
	{
		result = std::stod(it->second);
	}

	return result;
}

inline std::optional<bool> ConfigurationLoader::getOptionalBool_(const std::map<std::string, std::string>& kv, const std::string& key)
{
	std::optional<bool> result;

	auto it = kv.find(key);

	if(it == kv.end())
	{
		result.reset();
	}
	else
	{
		std::string s = utils::toLower(it->second);

		if (s == "true"  || s == "yes" || s == "on")
		{
			result = true;
		}
		else if (s == "false" || s == "no"  || s == "off")
		{
			result = false;
		}
		else
		{
			global().fatal("ConfigurationLoader::getOptionalBool_") << "Invalid boolean value for key '" + key + "': '" + it->second + "'";
			throw std::runtime_error("Invalid boolean value for key '" + key + "': '" + it->second + "'");
		}
	}

	return result;
}

inline bool ConfigurationLoader::hasKey_(const std::map<std::string, std::string>& kv, const std::string& key)
{
    return kv.contains(key); // C++20
    // return kv.find(key) != kv.end(); // C++17でもOK
}

inline int ConfigurationLoader::countArrayEntries_(const std::map<std::string, std::string>& kv, const std::string& prefix)
{
	const std::string pfx = prefix + ".";
	std::vector<char> seen;  // seen[i] が 1 なら index=i が存在

	for (auto& [key,val] : kv)
	{
		// "prefix." で始まらないものはスキップ
		if (key.rfind(pfx, 0) != 0) continue;

		// pfx の直後から、次の '.' まで or 末尾までを番号文字列として抜き出す
		size_t pos1 = pfx.size();
		size_t pos2 = key.find('.', pos1);
		std::string idxstr = (pos2 == std::string::npos) ? key.substr(pos1) : key.substr(pos1, pos2 - pos1);
		if (idxstr.empty())
		{
			continue;
		}

		// 純粋に数字だけかチェック
		bool ok = true;
		for (char c : idxstr)
		{
			if (!std::isdigit(static_cast<unsigned char>(c)))
			{
				ok = false;
				break;
			}
		}

		if (!ok)
		{
			continue;
		}

		int idx = std::stoi(idxstr);
		if (idx < 0)
		{
			continue;
		}

		// seen を必要な長さまで拡張してマーク
		if ((size_t)idx >= seen.size())
		{
			seen.resize(idx + 1, 0);
		}

		seen[idx] = 1;
	}

	// true (1) になっているものを数える
	return std::count(seen.begin(), seen.end(), 1);
}

template<typename EnumT> inline std::optional<EnumT> ConfigurationLoader::parseEnum_(const std::optional<std::string>& s, const std::map<std::string, EnumT>& mapping)
{
	if (!s.has_value())
	{
		return std::nullopt;
	}

	// 2. 値を取り出して大文字に
	std::string s_u = utils::toUpper(s.value());

	// 3. マップから探す
	auto it = mapping.find(s_u);
	if (it != mapping.end())
	{
		// 4. 見つかったらEnum値を返す
		return it->second;
	}

	// 5. 見つからなければ例外を投げる
	global().fatal("ConfigurationLoader::parseEnum_") << "Unknown TypeName: " + s.value();
	throw std::runtime_error("Unknown TypeName: " + s.value());
}

};
#pragma once

#include <cmath>
#include <vector>
#include <algorithm>
#include "Types"
#include "Constants"
#include "../io/Logger"

#include <omp.h>

namespace aad::physics
{

double interpolateVerticalProfile(double, const std::vector<std::vector<double>>&, VerticalProfileInterpolation);
double computePlanckFunction(double, double, SpectralCoordinateDimension);
double computeThermalEmission(double, double, double);

/*
inline double ModelBuilder::interpolateVerticalProfile(double x, const std::vector<std::vector<double>>& table, VerticalProfileInterpolation type)
{
	if (table.empty()) return 0.0;

	// 2. 範囲外チェック (外挿はせず、端の値を返すか0を返すか仕様による)
	// ここでは範囲外なら 0.0 を返す（元のコード準拠）
	if (x < table.front()[0] || x > table.back()[0])
	{
		return 0.0; 
	}

	// 3. 二分探索 (std::lower_bound) で高速に区間を見つける
	// イテレータ it は、x 以上の最初の要素を指す
	auto it = std::lower_bound(table.begin(), table.end(), x, [](const std::vector<double>& row, double val){return row[0] < val;});

	// x がテーブルの最初の要素と一致する場合のケア
	if (it == table.begin())
	{
		return table.front()[1];
	}

	// it は区間の「右端」なので、一つ戻って「左端」を取得
	size_t j = std::distance(table.begin(), it) - 1;

	// 4. 補間係数 r の計算
	double x0 = table[j][0];
	double x1 = table[j + 1][0];
	double y0 = table[j][1];
	double y1 = table[j + 1][1];

	// 分母が0になるケース（同じ高度のデータが連続している等）をケア
	if (std::abs(x1 - x0) < 1.0e-9) return y0;

	double r = (x - x0) / (x1 - x0);

	// 5. 値の計算
	if (type == VerticalProfileInterpolation::Linear)
	{
		// 線形補間: y = (1-r)y0 + r*y1
		return ((1.0 - r) * y0 + r * y1);
	}
	else
	{ 
		// 指数補間: y = exp( (1-r)ln(y0) + r*ln(y1) )
		// 安全対策: 値が正でなければ線形補間にフォールバック、または微小値を代入
		if (y0 <= 0.0 || y1 <= 0.0) 
		{
			// 0以下の値の対数は取れないため、線形で返すか、0とみなす
			return ((1.0 - r) * y0 + r * y1);
		}

		double log0 = std::log(y0);
		double log1 = std::log(y1);
		
		// 計算後にまとめて scale_value を掛ける方が log の計算回数が減る
		// exp(ln(y)) * scale = y * scale
		return std::exp((1.0 - r) * log0 + r * log1);
	}
}
*/

inline double interpolateVerticalProfile(double x, const std::vector<std::vector<double>>& table, VerticalProfileInterpolation type)
{
	if (table.empty()) return 0.0;

	// 2. 範囲外チェック (外挿はせず、端の値を返すか0を返すか仕様による)
	// ここでは範囲外なら 0.0 を返す（元のコード準拠）
	if (x < table.front()[0] || x > table.back()[0])
	{
		return 0.0; 
	}

	// 3. 二分探索 (std::lower_bound) で高速に区間を見つける
	// イテレータ it は、x 以上の最初の要素を指す
	auto it = std::lower_bound(table.begin(), table.end(), x, [](const std::vector<double>& row, double val){return row[0] < val;});

	// x がテーブルの最初の要素と一致する場合のケア
	if (it == table.begin())
	{
		return table.front()[1];
	}

	// it は区間の「右端」なので、一つ戻って「左端」を取得
	size_t j = std::distance(table.begin(), it) - 1;

	// 4. 補間係数 r の計算
	double x0 = table[j][0];
	double x1 = table[j + 1][0];
	double y0 = table[j][1];
	double y1 = table[j + 1][1];

	// 分母が0になるケース（同じ高度のデータが連続している等）をケア
	if (std::abs(x1 - x0) < 1.0e-9) return y0;

	double r = (x - x0) / (x1 - x0);

	// 5. 値の計算
	if (type == VerticalProfileInterpolation::Linear)
	{
		// 線形補間: y = (1-r)y0 + r*y1
		return ((1.0 - r) * y0 + r * y1);
	}
	else
	{ 
		// 指数補間: y = exp( (1-r)ln(y0) + r*ln(y1) )
		// 安全対策: 値が正でなければ線形補間にフォールバック、または微小値を代入
		if (y0 <= 0.0 || y1 <= 0.0) 
		{
			// 0以下の値の対数は取れないため、線形で返すか、0とみなす
			return ((1.0 - r) * y0 + r * y1);
		}

		double log0 = std::log(y0);
		double log1 = std::log(y1);
		
		// 計算後にまとめて scale_value を掛ける方が log の計算回数が減る
		// exp(ln(y)) * scale = y * scale
		return std::exp((1.0 - r) * log0 + r * log1);
	}
}

inline double computePlanckFunction(double spectral, double temperature, SpectralCoordinateDimension dimension)
{
	double B = 0.0;

	if(dimension == SpectralCoordinateDimension::Wavelength)
	{
		B = 2.0 * SPEED_OF_LIGHT * SPEED_OF_LIGHT * PLANCK_CONSTANT;
		B /= std::pow(spectral, 5);
		B /= (std::exp(PLANCK_CONSTANT *SPEED_OF_LIGHT / (spectral * BOLTZMANN_CONSTANT * temperature)) - 1.0);
		
	}
	else if(dimension == SpectralCoordinateDimension::Wavenumber)
	{
		B = 2.0 * PLANCK_CONSTANT * SPEED_OF_LIGHT * SPEED_OF_LIGHT * std::pow(spectral, 3);
		B /= (std::exp(PLANCK_CONSTANT * SPEED_OF_LIGHT * spectral / (BOLTZMANN_CONSTANT * temperature)) - 1.0);
	}

	return B; // [W/m2/sr/m] or [W/m2/sr/m-1]
}

inline double computeThermalEmission(double plank_function, double tau, double mu)
{
	// 1 – exp(‑τ/μ)  ---  use expm1 for numerical safety when τ is very small.
	return plank_function * (-std::expm1(-tau / mu));
}

inline void Configuration::validateConfiguration(void)
{
	// Simulation
	// if(!simulation.simulation_name.has_value())
	// {
	// 	simulation.simulation_name = "untitled";
	// 	io::global().warn("Configuration::validateConfiguration") << "Simulation name was not specified. Automatically set to '" << simulation.simulation_name.value() << "'.";
	// }
	// if(!simulation.directory_name.has_value())
	// {
	// 	simulation.directory_name = "./";
	// 	if(simulation.directory_name.value()[simulation.directory_name.value().size() - 1] != '/')
	// 	{
	// 		simulation.directory_name = simulation.directory_name.value() + "/";
	// 	}
	// 	io::global().warn("Configuration::validateConfiguration") << "Working directroy was not specified. Automatically set to current directory.";
	// }
	if(!simulation.result_name.has_value())
	{
		simulation.result_name = simulation.simulation_name.value() + ".nc";
		io::global().warn("Configuration::validateConfiguration") << "Result file name was not specified. Automatically set to '" << simulation.simulation_name.value() << ".nc'.";
	}
	if(!simulation.n_parallel.has_value())
	{
		simulation.n_parallel = 1;
		io::global().warn("Configuration::validateConfiguration") << "n_parallel was not specified. Automatically set to " << simulation.n_parallel.value() << ".";
	}
	else
	{
		int max_threads = omp_get_max_threads();
		if(simulation.n_parallel.value() > max_threads)
		{
			simulation.n_parallel = max_threads;
			io::global().warn("Configuration::validateConfiguration") << "n_parallel exceeds max_threads. Automatically set to " << max_threads << ".";
		}
	}
	if(!simulation.n_scattering_angle.has_value())
	{
		simulation.n_scattering_angle = 1001;
		io::global().warn("Configuration::validateConfiguration") << "n_scattering_angle was not specified. Automatically set to " << simulation.n_scattering_angle.value() << ".";
	}
	if(!simulation.tau_initial_layer.has_value())
	{
		simulation.tau_initial_layer = 1.0E-8;
		io::global().warn("Configuration::validateConfiguration") << "tau_initial_layer was not specified. Automatically set to " << simulation.tau_initial_layer.value() << ".";
	}
	if(!simulation.enable_atmospheric_emission.has_value())
	{
		simulation.enable_atmospheric_emission = false;
		io::global().warn("Configuration::validateConfiguration") << "enable_atmospheric_emission was not specified. Automatically set to false.";
	}

	//Geometry
	if(!geometry.grid_type.has_value())
	{
		geometry.grid_type = core::GridType::GaussRadau;
		io::global().warn("Configuration::validateConfiguration") << "grid_type was not specified. Automatically set to Gauss-Radau.";
	}
	if(!geometry.n_theta.has_value())
	{
		io::global().fatal("Configuration::validateConfiguration") << "n_theta was not specified.";
		throw std::runtime_error("[Configuration::validateConfiguration] n_theta was not specified.");
	}
	if(!geometry.n_phi.has_value() && !geometry.n_mode.has_value())
	{
		io::global().warn("Configuration::validateConfiguration") << "n_phi and n_mode were not specified. Automatically set.";
	}

	//DeltaM
	if(!delta_m.delta_approximation_type.has_value())
	{
		delta_m.delta_approximation_type = physics::DeltaApproximationType::Disable;
		io::global().warn("Configuration::validateConfiguration") << "delta_approximation_type was not specified. Automatically set to disable.";
	}
	else
	{
		if(delta_m.delta_approximation_type.value() == physics::DeltaApproximationType::Cumulative)
		{
			if(!delta_m.f_target.has_value())
			{
				io::global().fatal("Configuration::validateConfiguration") << "f_target was not specified.";
				throw std::runtime_error("[Configuration::validateConfiguration] f_target was not specified.");
			}
		}
		else if(delta_m.delta_approximation_type.value() == physics::DeltaApproximationType::FWHM)
		{
			if(!delta_m.fwhm_ratio.has_value())
			{
				io::global().fatal("Configuration::validateConfiguration") << "fwhm_ratio was not specified.";
				throw std::runtime_error("[Configuration::validateConfiguration] fwhm_ratio was not specified.");
			}
		}
	}

	// SpectralCoordinate
	// 有効な組み合わせ
	// monochrome
	// spectrum
	// table (あまり使わないほうが良い)
	// bandpass + instrument (bandpass filter)
	// spectrum + instrument
	if(!spectral_coordinate.spectral_coordinate_dimension.has_value() && !spectral_coordinate.unit.has_value())
	{
		io::global().fatal("Configuration::validateConfiguration") << "Spectral dimension not automatically determined. Specify at least dimension or unit.";
		throw std::runtime_error("[Configuration::validateConfiguration] Spectral dimension not automatically determined. Specify at least dimension or unit.");
	}
	else if(!spectral_coordinate.spectral_coordinate_dimension.has_value() && spectral_coordinate.unit.has_value())
	{
		if(getUnitInfo(spectral_coordinate.unit.value()).dim == physics::UnitDim::Length)
		{
			spectral_coordinate.spectral_coordinate_dimension = SpectralCoordinateDimension::Wavelength;
			io::global().warn("Configuration::validateConfiguration") << "Spectral dimension was not specified. Automatically set to wavelength.";
		}
		else if(getUnitInfo(spectral_coordinate.unit.value()).dim == physics::UnitDim::Wavenumber)
		{
			spectral_coordinate.spectral_coordinate_dimension = SpectralCoordinateDimension::Wavenumber;
			io::global().warn("Configuration::validateConfiguration") << "Spectral dimension was not specified. Automatically set to wavenumber.";
		}
	}
	else if(spectral_coordinate.spectral_coordinate_dimension.has_value() && !spectral_coordinate.unit.has_value())
	{
		if(spectral_coordinate.spectral_coordinate_dimension == SpectralCoordinateDimension::Wavenumber)
		{
			spectral_coordinate.unit = "m-1";
			io::global().warn("Configuration::validateConfiguration") << "Spectral unit was not specified. Automatically set to " << spectral_coordinate.unit.value() << ".";
		}
		if(spectral_coordinate.spectral_coordinate_dimension == SpectralCoordinateDimension::Wavelength)
		{
			spectral_coordinate.unit = "m";
			io::global().warn("Configuration::validateConfiguration") << "Spectral unit was not specified. Automatically set to " << spectral_coordinate.unit.value() << ".";
		}
	}
	if(!spectral_coordinate.spectral_coordinate_type.has_value())
	{
		io::global().fatal("Configuration::validateConfiguration") << "Spectral coordinate type was not specified.";
		throw std::runtime_error("[Configuration::validateConfiguration] Spectral coordinate type was not specified.");
	}
	else if(spectral_coordinate.spectral_coordinate_type.value() == physics::SpectralCoordinateType::Monochrome)
	{
		if(!spectral_coordinate.mono.has_value())
		{
			io::global().fatal("Configuration::validateConfiguration") << "Wavenumber or wavelength were not specified for monochrome calculation.";
			throw std::runtime_error("[Configuration::validateConfiguration] Wavenumber or wavelength were not specified for monochrome calculation.");
		}
	}
	else if(spectral_coordinate.spectral_coordinate_type.value() == physics::SpectralCoordinateType::Spectrum)
	{
		if(!spectral_coordinate.min.has_value() || !spectral_coordinate.max.has_value())
		{
			io::global().fatal("Configuration::validateConfiguration") << "Spectral range was not specified.";
			throw std::runtime_error("[Configuration::validateConfiguration] Spectral range was not specified.");
		}

		if(spectral_coordinate.min.value() >= spectral_coordinate.max.value())
		{
			io::global().fatal("Configuration::validateConfiguration") << "Spectral range error (min >= max).";
			throw std::runtime_error("[Configuration::validateConfiguration] Spectral range error (min >= max).");
		}
		
		if(!instrument.convolution_kernel_type.has_value() || instrument.convolution_kernel_type == physics::InstrumentFunctionType::Delta)
		{
			instrument.convolution_kernel_type = physics::InstrumentFunctionType::Delta;

			if(!spectral_coordinate.n_spectral.has_value() && !spectral_coordinate.increment.has_value())
			{
				io::global().fatal("Configuration::validateConfiguration") << "Spectral increment was not specified.";
				throw std::runtime_error("[Configuration::validateConfiguration] Spectral increment was not specified.");
			}
			else if(spectral_coordinate.n_spectral.has_value() && spectral_coordinate.increment.has_value())
			{
				io::global().fatal("Configuration::validateConfiguration") << "Spectral increment was over specified.";
				throw std::runtime_error("[Configuration::validateConfiguration] Spectral increment was over specified.");
			}
			else
			{
				if(!spectral_coordinate.n_spectral.has_value())
				{
					if(spectral_coordinate.max.value() - spectral_coordinate.min.value() < spectral_coordinate.increment.value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "Spectral range error (width < increment).";
						throw std::runtime_error("[Configuration::validateConfiguration] Spectral range error (width < increment).");
					}
				}
				else if(!spectral_coordinate.increment.has_value())
				{
					if(spectral_coordinate.n_spectral < 2)
					{
						spectral_coordinate.n_spectral = 2;
						io::global().warn("Configuration::validateConfiguration") << "n_spectral is too few. Automatically set to 2 (min and max).";
					}
				}
			}
		}
		else
		{
			if(!instrument.over_sampling_count.has_value())
			{
				instrument.over_sampling_count = 3;
				io::global().warn("Configuration::validateConfiguration") << "over_sampling_count was not specified. Automatically set to " << instrument.over_sampling_count.value() << ".";
			}

			if(instrument.convolution_kernel_type.value() == physics::InstrumentFunctionType::Gauss)
			{
				if(!instrument.kernel_sigma.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Gaussian sigma was not specified for convolution kernel.";
					throw std::runtime_error("[Configuration::validateConfiguration] Gaussian sigma was not specified for convolution kernel.");
				}
				if(instrument.kernel_width.has_value())
				{
					instrument.kernel_width.reset();
					io::global().warn("Configuration::validateConfiguration") << "Rectangular width was ignored for gaussian spectrum convolution kernel.";
				}
				if(!instrument.kernel_cut_off_sigma.has_value())
				{
					instrument.kernel_cut_off_sigma = 3.0;
					std::cout <<  "[Configuration::validateConfiguration] Cutoff sigma of Gaussian convolution kernel was not specified. Automatically set to " << instrument.kernel_cut_off_sigma.value() << ".";
				}
			}
			else if(instrument.convolution_kernel_type.value() == physics::InstrumentFunctionType::Rectangle)
			{
				if(!instrument.kernel_width.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Rectangular width was not specified for convolution kernel.";
					throw std::runtime_error("[Configuration::validateConfiguration] Rectangular width was not specified for convolution kernel.");
				}
				if(instrument.kernel_sigma.has_value())
				{
					instrument.kernel_width.reset();
					io::global().warn("Configuration::validateConfiguration") << "Gaussian sigma was ignored for rectangular spectrum convolution kernel.";
				}
			}
			else if(instrument.convolution_kernel_type.value() == physics::InstrumentFunctionType::External)
			{
				io::global().fatal("Configuration::validateConfiguration") << "External was not currently supported for spectrum convolution kernel.";
				throw std::runtime_error("[Configuration::validateConfiguration] External was not currently supported for spectrum convolution kernel.");
			} 
		}
	}
	else if(spectral_coordinate.spectral_coordinate_type.value() == physics::SpectralCoordinateType::Bandpass)
	{
		if(!instrument.filter_function_type.has_value())
		{
			io::global().fatal("Configuration::validateConfiguration") << "Bandpass filter was not specified for bandpass calculation.";
			throw std::runtime_error("[Configuration::validateConfiguration] Bandpass filter was not specified for bandpass calculation.");
		}
		else 
		{
			if(instrument.filter_function_type.value() == physics::InstrumentFunctionType::Delta)
			{
				if(!instrument.filter_center.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Delta center was not specified for filter function.";
					throw std::runtime_error("[Configuration::validateConfiguration] Delta center was not specified for filter function.");
				}
			}
			else if(instrument.filter_function_type.value() == physics::InstrumentFunctionType::Gauss)
			{
				if(!instrument.filter_sigma.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Gaussian sigma was not specified for filter function.";
					throw std::runtime_error("[Configuration::validateConfiguration] Gaussian sigma was not specified for filter function.");
				}
				if(!instrument.filter_center.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Gaussian center was not specified for filter function.";
					throw std::runtime_error("[Configuration::validateConfiguration] Gaussian center was not specified for filter function.");
				}
				if(!instrument.filter_cut_off_sigma.has_value())
				{
					instrument.filter_cut_off_sigma = 3.0;
					std::cout <<  "[Configuration::validateConfiguration] Cutoff sigma of Gaussian filter function was not specified. Automatically set to " << instrument.filter_cut_off_sigma.value() << ".";
				}
			}
			else if(instrument.filter_function_type.value() == physics::InstrumentFunctionType::Rectangle)
			{
				if(!instrument.filter_width.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Rectangular width was not specified for filter function.";
					throw std::runtime_error("[Configuration::validateConfiguration] Rectangular width was not specified for filter function.");
				}
				if(!instrument.filter_center.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Rectangular center was not specified for filter function.";
					throw std::runtime_error("[Configuration::validateConfiguration] Rectangular center was not specified for filter function.");
				}
			}
			else if(instrument.filter_function_type.value() == physics::InstrumentFunctionType::External)
			{
				if(!instrument.filename_filter_function.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Filename of filter function was not specified.";
					throw std::runtime_error("[Configuration::validateConfiguration] Filename of filter function was not specified.");
				}
				else if(!instrument.varname_spectral.has_value() || !instrument.varname_transmittance.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Variable name of filter function file was not specified.";
					throw std::runtime_error("[Configuration::validateConfiguration] Variable name of filter function file was not specified.");
				}

				if(!instrument.filter_cut_off.has_value())
				{
					instrument.filter_cut_off = 0.001;
					std::cout <<  "[Configuration::validateConfiguration] Cutoff threshold of filter function was not specified. Automatically set to " << instrument.filter_cut_off.value() << ".";
				}
			}
		}
	}

	// Surface
	if(!surface.type.has_value())
	{
		surface.type = physics::SurfaceType::NoSurface;
		io::global().warn("Configuration::validateConfiguration") << "surface_type was not specified. Automatically set to no_surface.";
	}
	else if(surface.type.value() == physics::SurfaceType::Lambert)
	{
		if(!surface.albedo.has_value())
		{
			io::global().fatal("Configuration::validateConfiguration") << "surface_albedo was not specified.";
			throw std::runtime_error("[Configuration::validateConfiguration] surface_albedo was not specified.");
		}
		if(!surface.albedo.has_value())
		{
			surface.emissivity = 1.0 - surface.albedo.value();
			io::global().warn("Configuration::validateConfiguration") << "surface_emissivity was not specified. Automatically set to " << surface.emissivity.value() << "1-albedo.";
		}
		if(!surface.temperature.has_value())
		{
			io::global().fatal("Configuration::validateConfiguration") << "surface_temperature was not specified.";
			throw std::runtime_error("[Configuration::validateConfiguration] surface_temperature was not specified.");
		}
		if(!surface.unit.has_value())
		{
			surface.unit = "K";
			io::global().warn("Configuration::validateConfiguration") << "surface_temperature unit was not specified. Automatically set to K.";
		}
	}

	// Atmosphere-layering
	if(atmosphere.z_center.empty() && atmosphere.z_edge.empty())
	{
		io::global().fatal("Configuration::validateConfiguration") << "Layering was not specified.";
		throw std::runtime_error("[Configuration::validateConfiguration] Layering was not specified.");
	}
	else if(!atmosphere.z_center.empty() && !atmosphere.z_edge.empty())
	{
		io::global().fatal("Configuration::validateConfiguration") << "Layering was overspecified.";
		throw std::runtime_error("[Configuration::validateConfiguration] Layering was overspecified.");
	}
	if(!atmosphere.z_unit.has_value())
	{
		atmosphere.z_unit = "m";
		io::global().warn("Configuration::validateConfiguration") << "z_unit was not specified. Automatically set to m.";
	}
	// Atmosphere-temperature
	if(!atmosphere.vertical_temperature_profile.has_value())
	{
		io::global().fatal("Configuration::validateConfiguration") << "Temperature profile was not specified.";
		throw std::runtime_error("[Configuration::validateConfiguration] Temperature profile was not specified.");
	}
	else if(atmosphere.vertical_temperature_profile.value() == physics::VerticalTemperatureProfile::Table)
	{
		if(atmosphere.temperature_profile.empty())
		{
			io::global().fatal("Configuration::validateConfiguration") << "Temperature profile was not specified.";
			throw std::runtime_error("[Configuration::validateConfiguration] Temperature profile was not specified.");
		}
				
		if(atmosphere.is_same_temperature_layering_atmosphere == true)
		{
			if(atmosphere.temperature_unit.size() == 0)
			{
				atmosphere.temperature_unit = {atmosphere.z_unit.value(), "K"};
				io::global().warn("Configuration::validateConfiguration") << "Temperature unit was not specified. Automatically set to K.";
			}
			else if(atmosphere.temperature_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.temperature_unit[0].value()).dim != physics::UnitDim::Temperature)
				{
					io::global().fatal("Configuration::validateConfiguration") << "Invalid temperature unit dimension.";
					throw std::runtime_error("[Configuration::validateConfiguration] Invalid temperature unit dimension.");
				}
				else
				{
					atmosphere.temperature_unit = {atmosphere.z_unit.value(), atmosphere.temperature_unit[0].value()};
				}
			}
			else
			{
				io::global().fatal("Configuration::validateConfiguration") << "Temperature profile unit was overspecified.";
				throw std::runtime_error("[Configuration::validateConfiguration] Temperature profile unit was overspecified.");
			}
			if(!atmosphere.z_center.empty())
			{
				if(atmosphere.z_center.size() != atmosphere.temperature_profile.size())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Temperature layering does not match to atmosphere.";
					throw std::runtime_error("[Configuration::validateConfiguration] Temperature layering does not match to atmosphere.");
				}
			}
			else if(!atmosphere.z_edge.empty())
			{
				if(atmosphere.z_edge.size() - 1 != atmosphere.temperature_profile.size())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Temperature layering does not match to atmosphere.";
					throw std::runtime_error("[Configuration::validateConfiguration] Temperature layering does not match to atmosphere.");
				}
			}
		}
		else
		{
			if(!atmosphere.vertical_temperature_interpolation.has_value())
			{
				atmosphere.vertical_temperature_interpolation = physics::VerticalProfileInterpolation::Linear;
				io::global().warn("Configuration::validateConfiguration") << "Temperature interpolation was not specified. Automatically set to linear.";
			}
			if(atmosphere.temperature_unit.size() == 0)
			{
				atmosphere.temperature_unit = {atmosphere.z_unit.value(), "K"};
				io::global().warn("Configuration::validateConfiguration") << "(z, temperature) unit was not specified. Automatically set to (" << atmosphere.z_unit.value() << ", K).";
			}
			else if(atmosphere.temperature_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.temperature_unit[0].value()).dim == physics::UnitDim::Length)
				{
					atmosphere.temperature_unit.push_back(std::optional<std::string>("K"));
					io::global().warn("Configuration::validateConfiguration") << "Temperature unit was not specified. Automatically set to K.";
				}
				else if(getUnitInfo(atmosphere.temperature_unit[0].value()).dim == physics::UnitDim::Temperature)
				{
					atmosphere.temperature_unit.insert(atmosphere.temperature_unit.begin(), atmosphere.z_unit);
					io::global().warn("Configuration::validateConfiguration") << "z_unit for temperature was not specified. Automatically set to m.";
				}
			}
		}
	}
	else if(atmosphere.vertical_temperature_profile.value() == physics::VerticalTemperatureProfile::VIRA_EQUATOR || atmosphere.vertical_temperature_profile.value() == physics::VerticalTemperatureProfile::VIRA_45 || atmosphere.vertical_temperature_profile.value() == physics::VerticalTemperatureProfile::VIRA_60)
	{
		atmosphere.temperature_unit = {"km", "K"};

		if(!atmosphere.vertical_temperature_interpolation.has_value())
		{
			atmosphere.vertical_temperature_interpolation = physics::VerticalProfileInterpolation::Linear;
			io::global().warn("Configuration::validateConfiguration") << "Temperature interpolation was not specified. Automatically set to linear.";
			
		}
	}
	else if(atmosphere.vertical_temperature_profile.value() == physics::VerticalTemperatureProfile::External)
	{
		io::global().fatal("Configuration::validateConfiguration") << "Temperature profile 'External' is not supported currently.";
		throw std::runtime_error("[Configuration::validateConfiguration] Temperature profile 'External' is not supported currently.");
	}
	// Atmosphere-pressure
	if(!atmosphere.vertical_pressure_profile.has_value())
	{
		io::global().fatal("Configuration::validateConfiguration") << "Pressure profile was not specified.";
		throw std::runtime_error("[Configuration::validateConfiguration] Pressure profile was not specified.");
	}
	else if(atmosphere.vertical_pressure_profile.value() == physics::VerticalPressureProfile::Table)
	{
		if(atmosphere.pressure_profile.empty())
		{
			io::global().fatal("Configuration::validateConfiguration") << "Pressure profile was not specified.";
			throw std::runtime_error("[Configuration::validateConfiguration] Pressure profile was not specified.");
		}

		if(atmosphere.is_same_pressure_layering_atmosphere == true)
		{
			if(atmosphere.pressure_unit.size() == 0)
			{
				atmosphere.pressure_unit = {atmosphere.z_unit.value(), "Pa"};
				io::global().warn("Configuration::validateConfiguration") << "Pressure unit was not specified. Automatically set to Pa.";
			}
			else if(atmosphere.pressure_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.pressure_unit[0].value()).dim != physics::UnitDim::Pressure)
				{
					io::global().fatal("Configuration::validateConfiguration") << "Invalid pressure unit dimension.";
					throw std::runtime_error("[Configuration::validateConfiguration] Invalid pressure unit dimension.");
				}
				else
				{
					atmosphere.pressure_unit = {atmosphere.z_unit.value(), atmosphere.pressure_unit[0].value()};
				}
			}
			else
			{
				io::global().fatal("Configuration::validateConfiguration") << "Pressure profile unit was overspecified.";
				throw std::runtime_error("[Configuration::validateConfiguration] Pressure profile unit was overspecified.");
			}
			if(!atmosphere.z_center.empty())
			{
				if(atmosphere.z_center.size() != atmosphere.pressure_profile.size())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Pressure layering does not match to atmosphere.";
					throw std::runtime_error("[Configuration::validateConfiguration] Pressure layering does not match to atmosphere.");
				}
			}
			else if(!atmosphere.z_edge.empty())
			{
				if(atmosphere.z_edge.size() - 1 != atmosphere.pressure_profile.size())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Pressure layering does not match to atmosphere.";
					throw std::runtime_error("[Configuration::validateConfiguration] Pressure layering does not match to atmosphere.");
				}
			}
		}
		else
		{
			if(!atmosphere.vertical_pressure_interpolation.has_value())
			{
				atmosphere.vertical_pressure_interpolation = physics::VerticalProfileInterpolation::Exponential;
				io::global().warn("Configuration::validateConfiguration") << "Pressure interpolation was not specified. Automatically set to exponential.";
			}
			
			if(atmosphere.pressure_unit.size() == 0)
			{
				atmosphere.pressure_unit = {atmosphere.z_unit.value(), "Pa"};
				io::global().warn("Configuration::validateConfiguration") << "(z, pressure) unit was not specified. Automatically set to (" << atmosphere.z_unit.value() << ", Pa).";
			}
			else if(atmosphere.pressure_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.pressure_unit[0].value()).dim == physics::UnitDim::Length)
				{
					atmosphere.pressure_unit.push_back(std::optional<std::string>("Pa"));
					io::global().warn("Configuration::validateConfiguration") << "Pressure unit was not specified. Automatically set to Pa.";
				}
				else if(getUnitInfo(atmosphere.pressure_unit[0].value()).dim == physics::UnitDim::Pressure)
				{
					atmosphere.pressure_unit.insert(atmosphere.pressure_unit.begin(), atmosphere.z_unit);
					io::global().warn("Configuration::validateConfiguration") << "z_unit for pressure was not specified. Automatically set to m.";
				}
			}
		}
	}
	else if(atmosphere.vertical_pressure_profile.value() == physics::VerticalPressureProfile::VIRA_EQUATOR || atmosphere.vertical_pressure_profile.value() == physics::VerticalPressureProfile::VIRA_45 || atmosphere.vertical_pressure_profile.value() == physics::VerticalPressureProfile::VIRA_60)
	{
		atmosphere.pressure_unit = {"km", "bar"};

		if(!atmosphere.vertical_pressure_interpolation.has_value())
		{
			atmosphere.vertical_pressure_interpolation = physics::VerticalProfileInterpolation::Exponential;
			io::global().warn("Configuration::validateConfiguration") << "Pressure interpolation was not specified. Automatically set to exponential.";
		}
	}
	else if(atmosphere.vertical_pressure_profile.value() == physics::VerticalPressureProfile::Hydrostatic)
	{
		io::global().fatal("Configuration::validateConfiguration") << "Pressure profile 'Hydrostatic' is not supported currently.";
		throw std::runtime_error("[Configuration::validateConfiguration] Pressure profile 'Hydrostatic' is not supported currently.");
	}
	else if(atmosphere.vertical_pressure_profile.value() == physics::VerticalPressureProfile::External)
	{
		io::global().fatal("Configuration::validateConfiguration") << "Pressure profile 'External' is not supported currently.";
		throw std::runtime_error("[Configuration::validateConfiguration] Pressure profile 'External' is not supported currently.");
	}
	// Atmosphere-number_density
	if(!atmosphere.vertical_number_density_profile.has_value())
	{
		io::global().fatal("Configuration::validateConfiguration") << "Number density profile was not specified.";
		throw std::runtime_error("[Configuration::validateConfiguration] Number density profile was not specified.");
	}
	else if(atmosphere.vertical_number_density_profile.value() == physics::VerticalNumberDensityProfile::Table)
	{
		if(atmosphere.number_density_profile.empty())
		{
			io::global().fatal("Configuration::validateConfiguration") << "Number density profile was not specified.";
			throw std::runtime_error("[Configuration::validateConfiguration] Number density profile was not specified.");
		}

		if(atmosphere.is_same_number_density_layering_atmosphere == true)
		{
			if(atmosphere.number_density_unit.size() == 0)
			{
				atmosphere.number_density_unit = {atmosphere.z_unit.value(), "m-3"};
				atmosphere.unit_dim_number_density = getUnitInfo(atmosphere.number_density_unit[1].value()).dim;
				
				io::global().warn("Configuration::validateConfiguration") << "NumberDensity unit was not specified. Automatically set to m-3.";
			}
			else if(atmosphere.number_density_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.number_density_unit[0].value()).dim != physics::UnitDim::NumberDensity && getUnitInfo(atmosphere.number_density_unit[0].value()).dim != physics::UnitDim::ColumnNumberDensity)
				{
					io::global().fatal("Configuration::validateConfiguration") << "Invalid number_density unit dimension.";
					throw std::runtime_error("[Configuration::validateConfiguration] Invalid number_density unit dimension.");
				}
				else
				{
					atmosphere.number_density_unit = {atmosphere.z_unit.value(), atmosphere.number_density_unit[0].value()};
					atmosphere.unit_dim_number_density = getUnitInfo(atmosphere.number_density_unit[1].value()).dim;
				}
			}
			else
			{
				io::global().fatal("Configuration::validateConfiguration") << " NumberDensity profile unit was overspecified.";
				throw std::runtime_error("[Configuration::validateConfiguration] NumberDensity profile unit was overspecified.");
			}
			if(!atmosphere.z_center.empty())
			{
				if(atmosphere.z_center.size() != atmosphere.number_density_profile.size())
				{
					io::global().fatal("Configuration::validateConfiguration") << "NumberDensity layering does not match to atmosphere.";
					throw std::runtime_error("[Configuration::validateConfiguration] NumberDensity layering does not match to atmosphere.");
				}
			}
			else if(!atmosphere.z_edge.empty())
			{
				if(atmosphere.z_edge.size() - 1 != atmosphere.number_density_profile.size())
				{
					io::global().fatal("Configuration::validateConfiguration") << "NumberDensity layering does not match to atmosphere.";
					throw std::runtime_error("[Configuration::validateConfiguration] NumberDensity layering does not match to atmosphere.");
				}
			}
		}
		else
		{
			if(!atmosphere.vertical_number_density_interpolation.has_value())
			{
				atmosphere.vertical_number_density_interpolation = physics::VerticalProfileInterpolation::Exponential;
				io::global().warn("Configuration::validateConfiguration") << "Number density interpolation was not specified. Automatically set to exponential.";
			}
			
			if(atmosphere.number_density_unit.size() == 0)
			{
				atmosphere.number_density_unit = {atmosphere.z_unit.value(), "m-3"};
				atmosphere.unit_dim_number_density = getUnitInfo(atmosphere.number_density_unit[1].value()).dim;
				io::global().warn("Configuration::validateConfiguration") << "(z, number_density) unit was not specified. Automatically set to (" << atmosphere.z_unit.value() << ", m-3).";
			}
			else if(atmosphere.number_density_unit.size() == 1)
			{
				if(getUnitInfo(atmosphere.number_density_unit[0].value()).dim == physics::UnitDim::Length)
				{
					atmosphere.number_density_unit.push_back(std::optional<std::string>("m-3"));
					atmosphere.unit_dim_number_density = getUnitInfo(atmosphere.number_density_unit[1].value()).dim;
					io::global().warn("Configuration::validateConfiguration") << "Number density unit was not specified. Automatically set to m-3.";
				}
				else if(getUnitInfo(atmosphere.number_density_unit[0].value()).dim == physics::UnitDim::NumberDensity)
				{
					atmosphere.number_density_unit.insert(atmosphere.number_density_unit.begin(), atmosphere.z_unit);
					atmosphere.unit_dim_number_density = getUnitInfo(atmosphere.number_density_unit[1].value()).dim;
					io::global().warn("Configuration::validateConfiguration") << "z_unit for number_density was not specified. Automatically set to m.";
				}
			}
		}
	}
	else if(atmosphere.vertical_number_density_profile.value() == physics::VerticalNumberDensityProfile::VIRA_EQUATOR || atmosphere.vertical_number_density_profile.value() == physics::VerticalNumberDensityProfile::VIRA_45 || atmosphere.vertical_number_density_profile.value() == physics::VerticalNumberDensityProfile::VIRA_60)
	{
		atmosphere.number_density_unit = {"km", "m-3"};
		atmosphere.unit_dim_number_density = getUnitInfo(atmosphere.number_density_unit[1].value()).dim;

		if(!atmosphere.vertical_number_density_interpolation.has_value())
		{
			atmosphere.vertical_number_density_interpolation = physics::VerticalProfileInterpolation::Exponential;
			io::global().warn("Configuration::validateConfiguration") << "Number density interpolation was not specified. Automatically set to exponential.";
		}
	}
	else if(atmosphere.vertical_number_density_profile.value() == physics::VerticalNumberDensityProfile::External)
	{
		io::global().fatal("Configuration::validateConfiguration") << "Number density profile 'External' is not supported currently.";
		throw std::runtime_error("[Configuration::validateConfiguration] Number density profile 'External' is not supported currently.");
	}

	//species
	bool is_hitran = false;

	for(int i = 0; i < atmosphere.species_configuration.size(); ++i)
	{
		if(!atmosphere.species_configuration[i].name.has_value())
		{
			atmosphere.species_configuration[i].name = "species_" + std::to_string(i);
			io::global().warn("Configuration::validateConfiguration") << "Name of species " << i << " was not specified. Automatically set to " << atmosphere.species_configuration[i].name.value() << ".";
		}

		if(atmosphere.species_configuration[i].vertical_profile.empty())
		{
			io::global().fatal("Configuration::validateConfiguration") << "Vertical profile for species "+ std::to_string(i) + " was not specified.";
			throw std::runtime_error("[Configuration::validateConfiguration] Vertical profile for species "+ std::to_string(i) + " was not specified.");
		}
		
		if(atmosphere.species_configuration[i].is_same_layering_atmosphere == true)
		{
			if(atmosphere.species_configuration[i].unit_vertical_profile.size() == 0)
			{
				atmosphere.species_configuration[i].unit_vertical_profile = {atmosphere.z_unit.value(), "m-3"};
				io::global().warn("Configuration::validateConfiguration") << "Vertical profile unit was not specified for species " << i << ". Automatically set to m-3.";
			}
			else if(atmosphere.species_configuration[i].unit_vertical_profile.size() == 1)
			{
				atmosphere.species_configuration[i].unit_vertical_profile.insert(atmosphere.species_configuration[i].unit_vertical_profile.begin(), atmosphere.z_unit);
				
				if(getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[1].value()).dim != physics::UnitDim::Dimensionless && getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[1].value()).dim != physics::UnitDim::NumberDensity && getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[1].value()).dim != physics::UnitDim::ColumnNumberDensity)
				{
					io::global().fatal("Configuration::validateConfiguration") << "Invalid vertical profile unit dimension for species " + std::to_string(i) + ".";
					throw std::runtime_error("[Configuration::validateConfiguration] Invalid vertical profile unit dimension for species " + std::to_string(i) + ".");
				}
			}
			else
			{
				io::global().fatal("Configuration::validateConfiguration") << "Vertical profile unit for species " + std::to_string(i) + " was overspecified.";
				throw std::runtime_error("[Configuration::validateConfiguration] Vertical profile unit for species " + std::to_string(i) + " was overspecified.");
			}
			if(!atmosphere.z_center.empty())
			{
				if(atmosphere.z_center.size() != atmosphere.species_configuration[i].vertical_profile.size())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.";
					throw std::runtime_error("[Configuration::validateConfiguration] Vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.");
				}
			}
			else if(!atmosphere.z_edge.empty())
			{
				if(atmosphere.z_edge.size() - 1 != atmosphere.species_configuration[i].vertical_profile.size())
				{
					io::global().fatal("Configuration::validateConfiguration") << "Vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.";
					throw std::runtime_error("[Configuration::validateConfiguration] Vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.");
				}
			}
		}
		else
		{
			if(!atmosphere.species_configuration[i].vertical_profile_interpolation.has_value())
			{
				atmosphere.species_configuration[i].vertical_profile_interpolation = physics::VerticalProfileInterpolation::Exponential;
				io::global().warn("Configuration::validateConfiguration") << "Vertical profile interpolation for species "+ std::to_string(i) + " was not specified. Automatically set to exponential.";
			}
			
			if(atmosphere.species_configuration[i].unit_vertical_profile.size() == 0)
			{
				atmosphere.species_configuration[i].unit_vertical_profile = {atmosphere.z_unit.value(), "m-3"};
				io::global().warn("Configuration::validateConfiguration") << "(z, vertical_profile) unit for species " + std::to_string(i) + " was not specified. Automatically set to (" << atmosphere.z_unit.value() << ", m-3).";
			}
			else if(atmosphere.species_configuration[i].unit_vertical_profile.size() == 1)
			{
				if(getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[0].value()).dim == physics::UnitDim::Length)
				{
					atmosphere.species_configuration[i].unit_vertical_profile.push_back(std::optional<std::string>("m-3"));
					io::global().warn("Configuration::validateConfiguration") << "Vertical profile unit for species " + std::to_string(i) + " was not specified. Automatically set to m-3.";
				}
				else if(getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[0].value()).dim == physics::UnitDim::Dimensionless || getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[0].value()).dim == physics::UnitDim::NumberDensity || getUnitInfo(atmosphere.species_configuration[i].unit_vertical_profile[0].value()).dim == physics::UnitDim::ColumnNumberDensity)
				{
					atmosphere.species_configuration[i].unit_vertical_profile.insert(atmosphere.species_configuration[i].unit_vertical_profile.begin(), atmosphere.z_unit);
					io::global().warn("Configuration::validateConfiguration") << "z_unit for vertical profile for species " + std::to_string(i) + " was not specified. Automatically set to m.";
				}
			}
		}
	
		if(!atmosphere.species_configuration[i].species_state.has_value())
		{
			io::global().fatal("Configuration::validateConfiguration") << "species_state for species "+ std::to_string(i) + " was not specified.";
			throw std::runtime_error("[Configuration::validateConfiguration] species_state for species "+ std::to_string(i) + " was not specified.");
		}
		if(atmosphere.species_configuration[i].species_state.value() == physics::SpeciesState::Molecule && !atmosphere.species_configuration[i].species_type.has_value())
		{
			io::global().fatal("Configuration::validateConfiguration") << "species_type (scatterer, absorber or extinction) for species "+ std::to_string(i) + " was not specified.";
			throw std::runtime_error("[Configuration::validateConfiguration] species_type (scatterer, absorber or extinction) for species "+ std::to_string(i) + " was not specified.");
		}
		if(atmosphere.species_configuration[i].species_state.value() == physics::SpeciesState::Aerosol && atmosphere.species_configuration[i].species_type.has_value())
		{
			io::global().fatal("Configuration::validateConfiguration") << "species_type (scatterer, absorber or extinction) for aerosol species "+ std::to_string(i) + " was specified.";
			throw std::runtime_error("[Configuration::validateConfiguration] species_type (scatterer, absorber or extinction) for aerosol species "+ std::to_string(i) + " was specified.");
		}
		// 物性の整合性検証
		if(atmosphere.species_configuration[i].species_state.value() == physics::SpeciesState::Molecule)
		{
			if(atmosphere.species_configuration[i].species_type.value() == physics::SpeciesType::Scatterer || atmosphere.species_configuration[i].species_type.value() == physics::SpeciesType::Extinction)
			{
				if(!atmosphere.species_configuration[i].scatter_type.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "scatter_type for species "+ std::to_string(i) + " was not specified.";
					throw std::runtime_error("[Configuration::validateConfiguration] scatter_type for species "+ std::to_string(i) + " was not specified.");
				}
				else if(atmosphere.species_configuration[i].scatter_type.value() != physics::ScatterType::Mie)
				{
					if(!atmosphere.species_configuration[i].scattering_cross_section_type.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "scattering_cross_section_type for species "+ std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] scattering_cross_section_type for species "+ std::to_string(i) + " was not specified.");
					}
					else if(atmosphere.species_configuration[i].scattering_cross_section_type == physics::CrossSectionType::Constant)
					{
						if(!atmosphere.species_configuration[i].scattering_cross_section_unit.has_value())
						{
							atmosphere.species_configuration[i].scattering_cross_section_unit = "m2";
							io::global().warn("Configuration::validateConfiguration") << "scattering_cross_section_unit for species " + std::to_string(i) + " was not specified. Automatically set to m2.";
						}
						if(!atmosphere.species_configuration[i].scattering_cross_section.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "scattering_cross_section for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] scattering_cross_section for species "+ std::to_string(i) + " was not specified.");
						}
					}
					else if(atmosphere.species_configuration[i].scattering_cross_section_type == physics::CrossSectionType::External)
					{
						if(!atmosphere.species_configuration[i].varname_scattering_cross_section_spectral.has_value() || !atmosphere.species_configuration[i].varname_scattering_cross_section_temperature.has_value() || !atmosphere.species_configuration[i].varname_scattering_cross_section.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Variable name of scattering cross section file for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] Variable name of scattering cross section file for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].filename_scattering_cross_section.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "filename_scattering_cross_section for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] filename_scattering_cross_section for species "+ std::to_string(i) + " was not specified.");
						}
					}

					if(atmosphere.species_configuration[i].scatter_type.value() == physics::ScatterType::HenyeyGreenstein)
					{
						if(!atmosphere.species_configuration[i].g_factor.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "g_factor for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] g_factor for species "+ std::to_string(i) + " was not specified.");
						}
					}
				}
				else if(atmosphere.species_configuration[i].scatter_type.value() == physics::ScatterType::Mie)
				{
					io::global().fatal("Configuration::validateConfiguration") << "Mie scattering is not supported for molecules for species "+ std::to_string(i) + ". Use aerosol instead.";
					throw std::runtime_error("[Configuration::validateConfiguration] Mie scattering is not supported for molecules for species "+ std::to_string(i) + ". Use aerosol instead.");
				}
			}

			if(atmosphere.species_configuration[i].species_type.value() == physics::SpeciesType::Absorber || atmosphere.species_configuration[i].species_type.value() == physics::SpeciesType::Extinction)
			{
				if(!atmosphere.species_configuration[i].absorption_cross_section_type.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "absorption_cross_section_type for species "+ std::to_string(i) + " was not specified.";
					throw std::runtime_error("[Configuration::validateConfiguration] absorption_cross_section_type for species "+ std::to_string(i) + " was not specified.");
				}
				else if(atmosphere.species_configuration[i].absorption_cross_section_type == physics::CrossSectionType::Constant)
				{
					if(!atmosphere.species_configuration[i].absorption_cross_section_unit.has_value())
					{
						atmosphere.species_configuration[i].absorption_cross_section_unit = "m2";
						io::global().warn("Configuration::validateConfiguration") << "absorption_cross_section_unit for species " + std::to_string(i) + " was not specified. Automatically set to m2.";
					}
					if(!atmosphere.species_configuration[i].absorption_cross_section.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "absorption_cross_section for species "+ std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] absorption_cross_section for species "+ std::to_string(i) + " was not specified.");
					}
				}
				else if(atmosphere.species_configuration[i].absorption_cross_section_type == physics::CrossSectionType::External)
				{
					if(!atmosphere.species_configuration[i].varname_absorption_cross_section_spectral.has_value() || !atmosphere.species_configuration[i].varname_absorption_cross_section_temperature.has_value() || !atmosphere.species_configuration[i].varname_absorption_cross_section.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "Variable name of absorption cross section file for species "+ std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] Variable name of absorption cross section file for species "+ std::to_string(i) + " was not specified.");
					}
					if(!atmosphere.species_configuration[i].filename_absorption_cross_section.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "filename_absorption_cross_section for species "+ std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] filename_absorption_cross_section for species "+ std::to_string(i) + " was not specified.");
					}
					if(!atmosphere.species_configuration[i].filename_absorption_cross_section.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "filename_absorption_cross_section for species "+ std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] filename_absorption_cross_section for species "+ std::to_string(i) + " was not specified.");
					}
				}
				else if(atmosphere.species_configuration[i].absorption_cross_section_type == physics::CrossSectionType::HITRAN)
				{
					is_hitran = true;

					if(!atmosphere.species_configuration[i].molecule_id.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "molecule_id for species " + std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] molecule_id for species " + std::to_string(i) + " was not specified.");
					}

					if(!atmosphere.species_configuration[i].isotopologue_type.has_value())
					{
						atmosphere.species_configuration[i].isotopologue_type = physics::IsotopologueType::All;
						atmosphere.species_configuration[i].isotopologue_abundance_type = physics::IsotopologueAbundanceType::HITRAN;
						atmosphere.species_configuration[i].is_normalize = false;
						io::global().warn("Configuration::validateConfiguration") << "isotopologue_type for species " + std::to_string(i) + " was not specified. Automatically set to HITRAN.";
					}
					else if(atmosphere.species_configuration[i].isotopologue_type.value() == physics::IsotopologueType::Defined)
					{
						if(atmosphere.species_configuration[i].local_isotopologue_id.empty())
						{
							io::global().fatal("Configuration::validateConfiguration") << "local_isotopologue_id for species " + std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] local_isotopologue_id for species " + std::to_string(i) + " was not specified.");
						}

						std::vector<int> check_ids = atmosphere.species_configuration[i].local_isotopologue_id;
						std::sort(check_ids.begin(), check_ids.end());
						
						auto it = std::adjacent_find(check_ids.begin(), check_ids.end());

						if(it != check_ids.end())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Duplicate local_isotopologue_id (" + std::to_string(*it) + ") found for species " + std::to_string(i) + ".";
							throw std::runtime_error("[Configuration::validateConfiguration] Duplicate local_isotopologue_id (" + std::to_string(*it) + ") found for species " + std::to_string(i) + ".");
						}
					}
					else if(atmosphere.species_configuration[i].isotopologue_type.value() == physics::IsotopologueType::All)
					{
						if(!atmosphere.species_configuration[i].local_isotopologue_id.empty())
						{
							io::global().fatal("Configuration::validateConfiguration") << "local_isotopologue_id for species " + std::to_string(i) + " was overspecified.";
							throw std::runtime_error("[Configuration::validateConfiguration] local_isotopologue_id for species " + std::to_string(i) + " was overspecified.");
						}
					}

					if(!atmosphere.species_configuration[i].isotopologue_abundance_type.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "isotopologue_abundance_type for species " + std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] isotopologue_abundance_type for species " + std::to_string(i) + " was not specified.");
					}
					else if(atmosphere.species_configuration[i].isotopologue_abundance_type.value() == physics::IsotopologueAbundanceType::Defined)
					{
						if(atmosphere.species_configuration[i].abundance.empty())
						{
							io::global().fatal("Configuration::validateConfiguration") << "isotopologue abundance for species " + std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] isotopologue abundance for species " + std::to_string(i) + " was not specified.");
						}
						else if(atmosphere.species_configuration[i].isotopologue_type.value() == physics::IsotopologueType::Defined)
						{
							if(atmosphere.species_configuration[i].abundance.size() != atmosphere.species_configuration[i].local_isotopologue_id.size())
							{
								io::global().fatal("Configuration::validateConfiguration") << "isotopologue abundance for species " + std::to_string(i) + " mismatch to local id list.";
								throw std::runtime_error("[Configuration::validateConfiguration] isotopologue abundance for species " + std::to_string(i) + " mismatch to local id list.");
							}
						}
						else if(atmosphere.species_configuration[i].isotopologue_type.value() == physics::IsotopologueType::All)
						{
							if(atmosphere.species_configuration[i].abundance.size() != physics::isos_for_molecule(atmosphere.species_configuration[i].molecule_id.value()).size())
							{
								io::global().fatal("Configuration::validateConfiguration") << "isotopologue abundance for species " + std::to_string(i) + " mismatch to local id list.";
								throw std::runtime_error("[Configuration::validateConfiguration] isotopologue abundance for species " + std::to_string(i) + " mismatch to local id list.");
							}
						}
					}
					else if(atmosphere.species_configuration[i].isotopologue_abundance_type.value() == physics::IsotopologueAbundanceType::HITRAN)
					{
						if(!atmosphere.species_configuration[i].abundance.empty())
						{
							io::global().fatal("Configuration::validateConfiguration") << "isotopologue abundance for species "+ std::to_string(i) + " was overspecified.";
							throw std::runtime_error("[Configuration::validateConfiguration] isotopologue abundance for species "+ std::to_string(i) + " was overspecified.");
						}
					}

					if(!atmosphere.species_configuration[i].scalar.empty())
					{
						if(atmosphere.species_configuration[i].isotopologue_type.value() == physics::IsotopologueType::Defined)
						{
							if(atmosphere.species_configuration[i].scalar.size() != atmosphere.species_configuration[i].local_isotopologue_id.size())
							{
								io::global().fatal("Configuration::validateConfiguration") << "isotopologue scalar for species " + std::to_string(i) + " mismatch to local id list.";
								throw std::runtime_error("[Configuration::validateConfiguration] isotopologue scalar for species " + std::to_string(i) + " mismatch to local id list.");
							}
						}
						else if(atmosphere.species_configuration[i].isotopologue_type.value() == physics::IsotopologueType::All)
						{
							if(atmosphere.species_configuration[i].scalar.size() != physics::isos_for_molecule(atmosphere.species_configuration[i].molecule_id.value()).size())
							{
								io::global().fatal("Configuration::validateConfiguration") << "isotopologue scalar for species " + std::to_string(i) + " mismatch to local id list.";
								throw std::runtime_error("[Configuration::validateConfiguration] isotopologue scalar for species " + std::to_string(i) + " mismatch to local id list.");
							}
						}
					}

					if(!atmosphere.species_configuration[i].is_normalize.has_value())
					{
						atmosphere.species_configuration[i].is_normalize = false;
						io::global().warn("Configuration::validateConfiguration") << "normalization of isotopologue abundance for species " + std::to_string(i) + " was not specified. Automatically set to false.";
					}
				}
			}
		}
		else if(atmosphere.species_configuration[i].species_state.value() == physics::SpeciesState::Aerosol)
		{
			if(atmosphere.species_configuration[i].scatter_type.value() == physics::ScatterType::Mie)
			{
				//Mie計算に必要なもの：粒径, 複素屈折率
				if(!atmosphere.species_configuration[i].size_distribution.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "size_distribution for species "+ std::to_string(i) + " was not specified.";
					throw std::runtime_error("[Configuration::validateConfiguration] size_distribution for species "+ std::to_string(i) + " was not specified.");
				}
				if(!atmosphere.species_configuration[i].unit_input_radius.has_value())
				{
					atmosphere.species_configuration[i].unit_input_radius = "m";
					io::global().warn("Configuration::validateConfiguration") << "Unit of radius of species " << i << " was not specified. Automatically set to " << atmosphere.species_configuration[i].unit_input_radius.value() << ".";
				}
				
				if(atmosphere.species_configuration[i].size_distribution.value() == physics::ParticleSizeDistribution::Delta)
				{
					// 1. 必須パラメータのチェック (Deltaの半径: delta_r)
					if(!atmosphere.species_configuration[i].delta_r.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "Delta radius (r) for species "+ std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] Delta radius (r) for species "+ std::to_string(i) + " was not specified.");
					}

					// 2. 他の全分布パラメータの無視とリセット (Robustness)

					// Rectangular パラメータ
					if(atmosphere.species_configuration[i].rect_r_mean.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "rect_r_mean (r_mean) was ignored for Delta.";
						atmosphere.species_configuration[i].rect_r_mean.reset();
					}
					if(atmosphere.species_configuration[i].rect_width.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "rect_width (width) was ignored for Delta.";
						atmosphere.species_configuration[i].rect_width.reset();
					}

					// Log-Normal パラメータ (LND)
					if(atmosphere.species_configuration[i].lnd_r_g.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "lnd_r_g (r_g) was ignored for Delta.";
						atmosphere.species_configuration[i].lnd_r_g.reset();
					}
					if(atmosphere.species_configuration[i].lnd_sigma_g.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "lnd_sigma_g (sigma_g) was ignored for Delta.";
						atmosphere.species_configuration[i].lnd_sigma_g.reset();
					}
					
					// Gamma (GD) パラメータ
					if(atmosphere.species_configuration[i].gd_a.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "gd_a (a) was ignored for Delta.";
						atmosphere.species_configuration[i].gd_a.reset();
					}
					if(atmosphere.species_configuration[i].gd_b.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "gd_b (b) was ignored for Delta.";
						atmosphere.species_configuration[i].gd_b.reset();
					}
					
					// Modified Gamma (MGD) パラメータ
					if(atmosphere.species_configuration[i].mgd_r_c.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "mgd_r_c (r_c) was ignored for Delta.";
						atmosphere.species_configuration[i].mgd_r_c.reset();
					}
					if(atmosphere.species_configuration[i].mgd_alpha.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "mgd_alpha (alpha) was ignored for Delta.";
						atmosphere.species_configuration[i].mgd_alpha.reset();
					}
					if(atmosphere.species_configuration[i].mgd_gamma.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "mgd_gamma (beta) was ignored for Delta.";
						atmosphere.species_configuration[i].mgd_gamma.reset();
					}

					// Power Law (PL) パラメータ
					if(atmosphere.species_configuration[i].pl_delta.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "pl_delta (delta) was ignored for Delta.";
						atmosphere.species_configuration[i].pl_delta.reset();
					}
					if(atmosphere.species_configuration[i].pl_r1.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "pl_r1 (r_min) was ignored for Delta.";
						atmosphere.species_configuration[i].pl_r1.reset();
					}
					if(atmosphere.species_configuration[i].pl_r2.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "pl_r2 (r_max) was ignored for Delta.";
						atmosphere.species_configuration[i].pl_r2.reset();
					}

					// サンプリング設定 (Deltaは通常サンプリングをしないため)
					if(atmosphere.species_configuration[i].count_radius.has_value())
					{
						io::global().warn("Configuration::validateConfiguration") << "n_radius was ignored for Delta.";
						atmosphere.species_configuration[i].count_radius.reset();
					}
				}
				else 
				{
					if(!atmosphere.species_configuration[i].count_radius.has_value())
					{
						atmosphere.species_configuration[i].count_radius = 32;
						io::global().warn("Configuration::validateConfiguration") << "n_radius for species " << i << " was not specified. Automatically set to " << atmosphere.species_configuration[i].count_radius.value() << ".";

					}

					if(atmosphere.species_configuration[i].size_distribution.value() == physics::ParticleSizeDistribution::Rectangular)
					{
						// 1. 必須パラメータのチェック
						if(!atmosphere.species_configuration[i].rect_r_mean.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Rectangular mean radius (rect_r_mean) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] Rectangular mean radius (rect_r_mean) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].rect_width.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << " Rectangular width (rect_width) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] Rectangular width (rect_width) for species "+ std::to_string(i) + " was not specified.");
						}
						
						// 他の全分布パラメータの無視とリセット (Ignored Checks)
						if(atmosphere.species_configuration[i].delta_r.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "delta_r (r) was ignored for Rectangular.";
							atmosphere.species_configuration[i].delta_r.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_r_g.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "lnd_r_g (r_g) was ignored for Rectangular.";
							atmosphere.species_configuration[i].lnd_r_g.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_sigma_g.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "lnd_sigma_g (sigma_g) was ignored for Rectangular.";
							atmosphere.species_configuration[i].lnd_sigma_g.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_a.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "gd_a (a) was ignored for Rectangular.";
							atmosphere.species_configuration[i].gd_a.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_b.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "gd_b (b) was ignored for Rectangular.";
							atmosphere.species_configuration[i].gd_b.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_r_c.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_r_c (r_c) was ignored for Rectangular.";
							atmosphere.species_configuration[i].mgd_r_c.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_alpha.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_alpha (alpha) was ignored for Rectangular.";
							atmosphere.species_configuration[i].mgd_alpha.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_gamma.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_gamma (gamma) was ignored for Rectangular.";
							atmosphere.species_configuration[i].mgd_gamma.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_delta.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_delta (delta) was ignored for Rectangular.";
							atmosphere.species_configuration[i].pl_delta.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r1.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_r1 (r_min) was ignored for Rectangular.";
							atmosphere.species_configuration[i].pl_r1.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r2.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_r2 (r_max) was ignored for Rectangular.";
							atmosphere.species_configuration[i].pl_r2.reset(); 
						}
					}
					else if(atmosphere.species_configuration[i].size_distribution.value() == physics::ParticleSizeDistribution::LogNormal)
					{
						// 1. 必須パラメータのチェック
						if(!atmosphere.species_configuration[i].lnd_r_g.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "LogNormal geometric mean radius (r_g) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] LogNormal geometric mean radius (r_g) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].lnd_sigma_g.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "LogNormal log standard deviation (sigma_g) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] LogNormal log standard deviation (sigma_g) for species "+ std::to_string(i) + " was not specified.");
						}

						// 2. 他の全分布パラメータの無視とリセット (Ignored Checks)
						if(atmosphere.species_configuration[i].delta_r.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "delta_r (r) was ignored for LogNormal.";
							atmosphere.species_configuration[i].delta_r.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_r_mean.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "rect_r_mean (r_mean) was ignored for LogNormal.";
							atmosphere.species_configuration[i].rect_r_mean.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_width.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "rect_width (width) was ignored for LogNormal.";
							atmosphere.species_configuration[i].rect_width.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_a.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "gd_a (a) was ignored for LogNormal.";
							atmosphere.species_configuration[i].gd_a.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_b.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "gd_b (b) was ignored for LogNormal.";
							atmosphere.species_configuration[i].gd_b.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_r_c.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_r_c (r_c) was ignored for LogNormal.";
							atmosphere.species_configuration[i].mgd_r_c.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_alpha.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_alpha (alpha) was ignored for LogNormal.";
							atmosphere.species_configuration[i].mgd_alpha.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_gamma.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_gamma (gamma) was ignored for LogNormal.";
							atmosphere.species_configuration[i].mgd_gamma.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_delta.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_delta (delta) was ignored for LogNormal.";
							atmosphere.species_configuration[i].pl_delta.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r1.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_r1 (r_min) was ignored for LogNormal.";
							atmosphere.species_configuration[i].pl_r1.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r2.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_r2 (r_max) was ignored for LogNormal.";
							atmosphere.species_configuration[i].pl_r2.reset(); 
						}
					}
					else if(atmosphere.species_configuration[i].size_distribution.value() == physics::ParticleSizeDistribution::Gamma)
					{
						// 1. 必須パラメータのチェック
						if(!atmosphere.species_configuration[i].gd_a.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Gamma scale parameter (a) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] Gamma scale parameter (a) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].gd_b.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Gamma shape parameter (b) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] Gamma shape parameter (b) for species "+ std::to_string(i) + " was not specified.");
						}

						// 2. 他の全分布パラメータの無視とリセット (Ignored Checks)
						if(atmosphere.species_configuration[i].delta_r.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "delta_r (r) was ignored for Gamma.";
							atmosphere.species_configuration[i].delta_r.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_r_mean.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "rect_r_mean (r_mean) was ignored for Gamma.";
							atmosphere.species_configuration[i].rect_r_mean.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_width.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "rect_width (width) was ignored for Gamma.";
							atmosphere.species_configuration[i].rect_width.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_r_g.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "lnd_r_g (r_g) was ignored for Gamma.";
							atmosphere.species_configuration[i].lnd_r_g.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_sigma_g.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "lnd_sigma_g (sigma_g) was ignored for Gamma.";
							atmosphere.species_configuration[i].lnd_sigma_g.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_r_c.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_r_c (r_c) was ignored for Gamma.";
							atmosphere.species_configuration[i].mgd_r_c.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_alpha.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_alpha (alpha) was ignored for Gamma.";
							atmosphere.species_configuration[i].mgd_alpha.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_gamma.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_gamma (gamma) was ignored for Gamma.";
							atmosphere.species_configuration[i].mgd_gamma.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_delta.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_delta (delta) was ignored for Gamma.";
							atmosphere.species_configuration[i].pl_delta.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r1.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_r1 (r_min) was ignored for Gamma.";
							atmosphere.species_configuration[i].pl_r1.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r2.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_r2 (r_max) was ignored for Gamma.";
							atmosphere.species_configuration[i].pl_r2.reset(); 
						}
					}
					else if(atmosphere.species_configuration[i].size_distribution.value() == physics::ParticleSizeDistribution::ModifiedGamma)
					{
						// 1. 必須パラメータのチェック
						if(!atmosphere.species_configuration[i].mgd_r_c.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Modified Gamma characteristic radius (r_c) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] Modified Gamma characteristic radius (r_c) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].mgd_alpha.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Modified Gamma alpha shape (alpha) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] Modified Gamma alpha shape (alpha) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].mgd_gamma.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Modified Gamma gamma spread (gamma) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] Modified Gamma gamma spread (gamma) for species "+ std::to_string(i) + " was not specified.");
						}

						// 2. 他の全分布パラメータの無視とリセット (Ignored Checks)
						if(atmosphere.species_configuration[i].delta_r.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "delta_r (r) was ignored for Modified Gamma.";
							atmosphere.species_configuration[i].delta_r.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_r_mean.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "rect_r_mean (r_mean) was ignored for Modified Gamma.";
							atmosphere.species_configuration[i].rect_r_mean.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_width.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "rect_width (width) was ignored for Modified Gamma.";
							atmosphere.species_configuration[i].rect_width.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_r_g.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "lnd_r_g (r_g) was ignored for Modified Gamma.";
							atmosphere.species_configuration[i].lnd_r_g.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_sigma_g.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "lnd_sigma_g (sigma_g) was ignored for Modified Gamma.";
							atmosphere.species_configuration[i].lnd_sigma_g.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_a.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "gd_a (a) was ignored for Modified Gamma.";
							atmosphere.species_configuration[i].gd_a.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_b.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "gd_b (b) was ignored for Modified Gamma.";
							atmosphere.species_configuration[i].gd_b.reset(); 
						}
						// mgd_r_c, mgd_alpha, mgd_gamma は必須
						if(atmosphere.species_configuration[i].pl_delta.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_delta (delta) was ignored for Modified Gamma.";
							atmosphere.species_configuration[i].pl_delta.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r1.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_r1 (r_min) was ignored for Modified Gamma.";
							atmosphere.species_configuration[i].pl_r1.reset(); 
						}
						if(atmosphere.species_configuration[i].pl_r2.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "pl_r2 (r_max) was ignored for Modified Gamma.";
							atmosphere.species_configuration[i].pl_r2.reset(); 
						}
					}
					else if(atmosphere.species_configuration[i].size_distribution.value() == physics::ParticleSizeDistribution::PowerLaw)
					{
						// 1. 必須パラメータのチェック
						if(!atmosphere.species_configuration[i].pl_delta.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Power Law exponent (delta) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] Power Law exponent (delta) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].pl_r1.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Power Law minimum radius (r1) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] Power Law minimum radius (r1) for species "+ std::to_string(i) + " was not specified.");
						}
						if(!atmosphere.species_configuration[i].pl_r2.has_value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Power Law maximum radius (r2) for species "+ std::to_string(i) + " was not specified.";
							throw std::runtime_error("[Configuration::validateConfiguration] Power Law maximum radius (r2) for species "+ std::to_string(i) + " was not specified.");
						}

						// 1b. 物理的整合性チェック
						if(atmosphere.species_configuration[i].pl_r1.value() >= atmosphere.species_configuration[i].pl_r2.value())
						{
							io::global().fatal("Configuration::validateConfiguration") << "Power Law error: pl_r1 (r1) must be strictly less than pl_r2 (r2).";
							throw std::runtime_error("[Configuration::validateConfiguration] Power Law error: pl_r1 (r1) must be strictly less than pl_r2 (r2).");
						}

						// 2. 他の全分布パラメータの無視とリセット (Ignored Checks)
						if(atmosphere.species_configuration[i].delta_r.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "delta_r (r) was ignored for Power Law.";
							atmosphere.species_configuration[i].delta_r.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_r_mean.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "rect_r_mean (r_mean) was ignored for Power Law.";
							atmosphere.species_configuration[i].rect_r_mean.reset(); 
						}
						if(atmosphere.species_configuration[i].rect_width.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "rect_width (width) was ignored for Power Law.";
							atmosphere.species_configuration[i].rect_width.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_r_g.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "lnd_r_g (r_g) was ignored for Power Law.";
							atmosphere.species_configuration[i].lnd_r_g.reset(); 
						}
						if(atmosphere.species_configuration[i].lnd_sigma_g.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "lnd_sigma_g (sigma_g) was ignored for Power Law.";
							atmosphere.species_configuration[i].lnd_sigma_g.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_a.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "gd_a (a) was ignored for Power Law.";
							atmosphere.species_configuration[i].gd_a.reset(); 
						}
						if(atmosphere.species_configuration[i].gd_b.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "gd_b (b) was ignored for Power Law.";
							atmosphere.species_configuration[i].gd_b.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_r_c.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_r_c (r_c) was ignored for Power Law.";
							atmosphere.species_configuration[i].mgd_r_c.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_alpha.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_alpha (alpha) was ignored for Power Law.";
							atmosphere.species_configuration[i].mgd_alpha.reset(); 
						}
						if(atmosphere.species_configuration[i].mgd_gamma.has_value())
						{ 
							io::global().warn("Configuration::validateConfiguration") << "mgd_gamma (gamma) was ignored for Power Law.";
							atmosphere.species_configuration[i].mgd_gamma.reset(); 
						}
					}
				}


				// 高度・波長依存性
				if(!atmosphere.species_configuration[i].refractive_index_type.has_value())
				{
					io::global().fatal("Configuration::validateConfiguration") << "refractive_index_type for species "+ std::to_string(i) + " was not specified.";
					throw std::runtime_error("[Configuration::validateConfiguration] refractive_index_type for species "+ std::to_string(i) + " was not specified.");
				}
				else if(atmosphere.species_configuration[i].refractive_index_type.value() == physics::RefractiveIndexType::Constant)
				{
					if(!atmosphere.species_configuration[i].nr.has_value() || !atmosphere.species_configuration[i].ni.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "refractive_index value for species "+ std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] refractive_index value for species "+ std::to_string(i) + " was not specified.");
					}
				}
				else if(atmosphere.species_configuration[i].refractive_index_type.value() == physics::RefractiveIndexType::Spectral)
				{
					atmosphere.species_configuration[i].filename_refractive_index_spectral_vertical.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_altitude.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_spectral.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_nr.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_ni.reset();

					if(!atmosphere.species_configuration[i].filename_refractive_index_spectral.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "filename_refractive_index_spectral value for species "+ std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] filename_refractive_index_spectral value for species "+ std::to_string(i) + " was not specified.");
					}
					if(!atmosphere.species_configuration[i].varname_refractive_index_spectral_spectral.has_value() || !atmosphere.species_configuration[i].varname_refractive_index_spectral_nr.has_value() || !atmosphere.species_configuration[i].varname_refractive_index_spectral_ni.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "Variable name of refractive index spectral file for species "+ std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] Variable name of refractive index spectral file for species "+ std::to_string(i) + " was not specified.");
					}
				}
				else if(atmosphere.species_configuration[i].refractive_index_type.value() == physics::RefractiveIndexType::Vertical)
				{
					if(atmosphere.species_configuration[i].refractive_index_vertical_profile.empty())
					{
						io::global().fatal("Configuration::validateConfiguration") << "Vertical refractive index profile table for species " + std::to_string(i) + " is empty.";
						throw std::runtime_error("[Configuration::validateConfiguration] Vertical refractive index profile table for species " + std::to_string(i) + " is empty.");
					}
					
					if(atmosphere.species_configuration[i].is_refractive_index_same_layering_atmosphere == true)
					{
						if(!atmosphere.z_center.empty())
						{
							if(atmosphere.z_center.size() != atmosphere.species_configuration[i].refractive_index_vertical_profile.size())
							{
								io::global().fatal("Configuration::validateConfiguration") << "Refractive index vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.";
								throw std::runtime_error("[Configuration::validateConfiguration] Refractive index vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.");
							}
						}
						else if(!atmosphere.z_edge.empty())
						{							
							if(atmosphere.z_edge.size() - 1 != atmosphere.species_configuration[i].refractive_index_vertical_profile.size())
							{
								io::global().fatal("Configuration::validateConfiguration") << "Refractive index vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.";
								throw std::runtime_error("[Configuration::validateConfiguration] Refractive index vertical profile layering for species " + std::to_string(i) + " does not match to atmosphere.");
							}
						}
					}
					else
					{
						if(!atmosphere.species_configuration[i].refractive_index_vertical_profile_interpolation.has_value())
						{
							atmosphere.species_configuration[i].refractive_index_vertical_profile_interpolation = physics::VerticalProfileInterpolation::Linear;
							io::global().warn("Configuration::validateConfiguration") << "Refractive Index Vertical profile interpolation for species "+ std::to_string(i) + " was not specified. Automatically set to linear.";
						}
						
						if(!atmosphere.species_configuration[i].unit_refractive_index_vertical_profile.has_value())
						{
							atmosphere.species_configuration[i].unit_refractive_index_vertical_profile = atmosphere.z_unit.value();
							io::global().warn("Configuration::validateConfiguration") << "z unit of refractive index vertica profile for species " + std::to_string(i) + " was not specified. Automatically set to " << atmosphere.z_unit.value() << ".";
						}
					}
				}
				else if(atmosphere.species_configuration[i].refractive_index_type.value() == physics::RefractiveIndexType::SpectralVertical)
				{
					atmosphere.species_configuration[i].filename_refractive_index_spectral.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_spectral.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_nr.reset();
					atmosphere.species_configuration[i].varname_refractive_index_spectral_ni.reset();

					if(!atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_altitude.has_value() || !atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_spectral.has_value() || !atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_nr.has_value() || !atmosphere.species_configuration[i].varname_refractive_index_spectral_vertical_ni.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "Variable name of refractive index spectral-vertical file for species "+ std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] Variable name of refractive index spectral-vertical file for species "+ std::to_string(i) + " was not specified.");
					}
					
					if(!atmosphere.species_configuration[i].filename_refractive_index_spectral_vertical.has_value())
					{
						io::global().fatal("Configuration::validateConfiguration") << "filename_refractive_index_spectral_vertical value for species "+ std::to_string(i) + " was not specified.";
						throw std::runtime_error("[Configuration::validateConfiguration] filename_refractive_index_spectral_vertical value for species "+ std::to_string(i) + " was not specified.");
					}

					if(!atmosphere.species_configuration[i].refractive_index_vertical_profile_interpolation.has_value())
					{
						atmosphere.species_configuration[i].refractive_index_vertical_profile_interpolation = physics::VerticalProfileInterpolation::Linear;
						io::global().warn("Configuration::validateConfiguration") << "Refractive Index Vertical profile interpolation for species "+ std::to_string(i) + " was not specified. Automatically set to linear.";
					}
				}
			}
			else
			{
				io::global().fatal("Configuration::validateConfiguration") << "Only Mie scattering is supported for aerosol species "+ std::to_string(i) + ".";
				throw std::runtime_error("[Configuration::validateConfiguration] Only Mie scattering is supported for aerosol species "+ std::to_string(i) + ".");
			}
		}
	}

	//diluent
	if(is_hitran == true)
	{
		if(!atmosphere.filename_hitran.has_value())
		{
			io::global().fatal("Configuration::validateConfiguration") << "HITRAN netCDF file is not specified.";
			throw std::runtime_error("[Configuration::validateConfiguration] HITRAN netCDF file is not specified.");
		}
		// diluentの指定があるか確認
		// デフォルトは地球大気 (AIR)
		if(atmosphere.diluent_species.empty())
		{
			atmosphere.diluent_species.push_back("Air");
			atmosphere.diluent_ratio.push_back(1.0);
			io::global().warn("Configuration::validateConfiguration") << "Diluent is not specified. Automatically set to Air = 1.0.";
		}
		else
		{
			std::vector<std::string> dil_species = {"AIR", "CO2", "H2", "HE", "H2O"};
			std::vector<int> dil_count(5);
			for(int i = 0; i < atmosphere.diluent_species.size(); ++i)
			{
				std::string dil_sp = utils::toUpper(atmosphere.diluent_species[i]);
				
				bool found = false;
				for(int j = 0; j < dil_species.size(); ++j)
				{
					if(dil_sp == dil_species[j])
					{
						found = true;
						dil_count[j] ++;
						break;
					}
				}
				if(found == false)
				{
					io::global().fatal("Configuration::validateConfiguration") << "Unknown diluent species name: " + atmosphere.diluent_species[i] + ".";
					throw std::runtime_error("[Configuration::validateConfiguration] Unknown diluent species name: " + atmosphere.diluent_species[i] + ".");
				}
			}
			for(int i = 0; i < dil_count.size(); ++i)
			{
				if(dil_count[i] > 1)
				{
					io::global().fatal("Configuration::validateConfiguration") << "Diluent species " + dil_species[i] + " is duplicate.";
					throw std::runtime_error("[Configuration::validateConfiguration] Diluent species " + dil_species[i] + " is duplicate.");
				}
			}
		}
	}

	return;
}

}